<!DOCTYPE html>
<html>
<head>
    <title>Grand Traffic Racer - Vice City Pursuit</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Dancing+Script:wght@700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            -webkit-user-select: none;
            user-select: none;
        }
        #error-display {
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: rgba(150, 0, 0, 0.9);
            color: white; z-index: 9999; padding: 20px;
            font-family: monospace; font-size: 16px;
            white-space: pre-wrap; overflow-y: scroll;
            box-sizing: border-box;
        }
        #debug-info {
            position: fixed; top: 10px; left: 10px;
            background-color: rgba(0, 0, 0, 0.7); color: #00ff00;
            padding: 10px; font-family: 'Press Start 2P', cursive;
            font-size: 12px; z-index: 1000; border: 1px solid #00ff00;
            line-height: 1.5; pointer-events: none;
        }
        #speech-bubbles-container {
            position: fixed; top: 100px; right: 20px;
            width: 200px; z-index: 900; display: flex;
            flex-direction: column; gap: 15px; pointer-events: none;
        }
        .speech-bubble {
            padding: 10px; background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px; font-family: 'Bebas Neue', sans-serif;
            font-size: 18px; color: black; text-align: center;
            border-width: 3px; border-style: solid; position: relative;
            opacity: 0; transition: opacity 0.3s ease-in-out; display: none;
        }
        .speech-bubble.visible { opacity: 1; }
        .speech-bubble.player { border-color: #d9534f; }
        .speech-bubble.police { border-color: #5cb85c; }
        .speech-bubble::after {
            content: ''; position: absolute; bottom: 0;
            width: 0; height: 0; border: 15px solid transparent;
            border-top-color: inherit; border-bottom: 0; margin-left: -15px;
        }
        .speech-bubble.player::after { left: 80%; top: 100%; }
        .speech-bubble.police::after { left: 20%; top: 100%; }
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, #2c002e, #6a005f, #ff6a00, #ffb861);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 1s ease-out;
        }
        #creator-credit {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-family: 'Dancing Script', cursive;
            font-size: 4vw;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        @media (min-width: 768px) {
            #creator-credit {
                font-size: 38px;
            }
        }
        #loading-logo { text-align: center; color: white; }
        .studio-name {
            font-family: 'Bebas Neue', sans-serif; font-size: 8vw;
            margin: 0 0 -20px 0; color: #00ffff;
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 20px #00d5ff, 0 0 30px #00d5ff;
        }
        #loading-logo h1 {
            font-family: 'Bebas Neue', sans-serif; font-size: 15vw;
            margin: 0; line-height: 0.8; letter-spacing: 2px;
            text-shadow: 3px 3px 10px rgba(0,0,0,0.5); margin-top: 20px;
        }
        #loading-logo h2 {
            font-family: 'Dancing Script', cursive; font-size: 10vw;
            margin: 0; color: #ff89f3;
            text-shadow: 0 0 5px #ff89f3, 0 0 10px #ff89f3, 0 0 20px #ff00c1, 0 0 30px #ff00c1, 0 0 40px #ff00c1;
        }
        #loading-bar-container {
            width: 80%; max-width: 500px; height: 25px; background-color: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.5); border-radius: 15px;
            margin-top: 50px; padding: 3px; box-sizing: border-box;
        }
        #loading-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #d946ef 0%, #a200d6 100%);
            border-radius: 10px; transition: width 0.1s linear;
        }
        #loading-percentage {
            margin-top: 15px; font-family: 'Press Start 2P', cursive; color: white;
            font-size: 18px; text-shadow: 2px 2px 4px #000;
        }
        #name-entry-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85); color: white; display: none;
            flex-direction: column; justify-content: center; align-items: center;
            font-family: 'Press Start 2P', cursive; text-align: center;
            z-index: 99; opacity: 0; transition: opacity 1s ease-in-out;
        }
        #name-entry-screen.visible { display: flex; opacity: 1; }
        #name-entry-screen h2 { font-size: 8vw; text-shadow: 3px 3px 0px #c7006e; margin-bottom: 30px; }
        #name-entry-screen input {
            font-family: 'Press Start 2P', cursive; width: 80%; max-width: 400px; padding: 15px;
            font-size: 20px; text-align: center; background-color: #333;
            border: 2px solid white; color: white; border-radius: 10px;
        }
        #name-entry-screen button {
            margin-top: 30px; padding: 15px 25px; font-size: 20px; color: black;
            background-color: #e0e0e0; border: 2px solid #fff; border-radius: 10px;
            cursor: pointer; font-family: 'Press Start 2P', cursive;
        }
        #game, #ui-container, #mobile-controls, #mission-container {
            display: none; opacity: 0; transition: opacity 1s ease-in-out;
        }
        #game.visible, #ui-container.visible, #mobile-controls.visible, #mission-container.visible {
            display: block; opacity: 1;
        }
        #ui-container.visible, #mobile-controls.visible, #mission-container.visible { display: flex; }
        #ui-container {
            position: fixed; top: 0; left: 0; width: 100%; padding: 20px; box-sizing: border-box;
            justify-content: space-between; align-items: flex-start; pointer-events: none;
            font-family: 'Press Start 2P', cursive; color: white;
        }
        #left-ui { display: flex; flex-direction: column; align-items: flex-start; gap: 15px; }
        #right-ui { display: flex; flex-direction: column; align-items: flex-end; gap: 10px; text-align: right;}
        .ui-text { font-size: 24px; text-shadow: 2px 2px 4px #000; }
        #money-display { color: #85bb65; }
        #nitro-display { color: #00ffff; }
        #wanted-level { display: flex; gap: 8px; }
        .star { width: 30px; height: 30px; }
        #health-bar-container {
            width: 200px; height: 20px; background-color: rgba(0,0,0,0.5);
            border: 2px solid white; border-radius: 5px; padding: 2px;
        }
        #health-bar {
            width: 100%; height: 100%; background-color: #4CAF50; border-radius: 3px;
            transition: width 0.5s ease-out, background-color: 0.1s;
        }
        #health-bar.damaged { background-color: #f44336; }
        #game-over-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); color: white; display: none;
            flex-direction: column; justify-content: center; align-items: center;
            font-family: 'Press Start 2P', cursive; text-align: center;
        }
        #game-over-screen h1 { font-size: 10vw; text-shadow: 3px 3px 0px #c7006e; margin: 0; }
        #game-over-screen button {
            margin-top: 20px; padding: 15px 25px; font-size: 20px; color: black;
            background-color: #e0e0e0; border: 2px solid #fff; border-radius: 10px;
            cursor: pointer; pointer-events: auto; font-family: 'Press Start 2P', cursive;
        }
        #mobile-controls {
            position: fixed; bottom: 20px; width: 100%;
            justify-content: space-between; pointer-events: none; box-sizing: border-box;
        }
        #mobile-controls div { display: flex; padding: 0 20px; }
        #left-controls { flex-direction: column-reverse; align-items: center; }
        #right-controls { flex-direction: row; align-items: center; }
        .control-btn {
            width: 75px; height: 75px; background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5); color: white; font-size: 38px;
            font-weight: bold; border-radius: 50%; margin: 10px; display: flex;
            justify-content: center; align-items: center; -webkit-tap-highlight-color: transparent;
            pointer-events: auto; cursor: pointer; transition: background-color 0.1s ease;
        }
        #left-controls .control-btn { width: 80px; height: 80px; }
        .control-btn:active { background-color: rgba(255, 255, 255, 0.5); }
        #accel-btn.nitro-ready {
             background-color: rgba(0, 255, 255, 0.3);
             border-color: #00ffff;
        }
        @media (max-width: 768px) { #mobile-controls.visible { display: flex; } }
        #mission-container {
            position: fixed; top: 20px; right: 20px; width: 300px;
            background-color: rgba(0, 0, 0, 0.7); border: 2px solid #FF89F3;
            border-radius: 10px; padding: 15px; color: white;
            font-family: 'Press Start 2P', cursive; font-size: 14px;
            text-shadow: 1px 1px 2px #000; pointer-events: auto;
            flex-direction: column; gap: 10px;
            opacity: 0; transition: opacity 0.5s ease-out;
        }
        #mission-container.visible { opacity: 1; }
        #mission-text { min-height: 40px; display: flex; align-items: center; justify-content: center; text-align: center; }
        #generate-mission-btn {
            background-color: #00ffff; color: #2c002e; padding: 10px 15px;
            border: none; border-radius: 5px; font-family: 'Press Start 2P', cursive;
            font-size: 16px; cursor: pointer; box-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        #generate-mission-btn:hover { background-color: #54fcfd; box-shadow: 0 0 10px #54fcfd, 0 0 20px #54fcfd; }
        #generate-mission-btn:disabled { background-color: #555; box-shadow: none; cursor: not-allowed; }

        #radio-ticker-bar {
            position: fixed;
            bottom: 20px;
            left: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #00ff7f;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            padding: 8px;
            border: 1px solid #00ff7f;
            border-radius: 5px;
            overflow: hidden;
            white-space: nowrap;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #radio-ticker-bar.visible {
            opacity: 1;
        }
        #radio-ticker-text {
            display: inline-block;
            padding-left: 100%;
            animation: ticker-scroll 15s linear;
        }
        @keyframes ticker-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-150%); }
        }
    </style>
</head>
<body>
    <div id="error-display" style="display: none;"></div>
    <div id="debug-info"></div>
    <div id="speech-bubbles-container">
        <div id="player-speech-bubble" class="speech-bubble player"></div>
        <div id="police-speech-bubble" class="speech-bubble police"></div>
    </div>

    <div id="loading-screen">
        <div id="loading-logo">
            <h2 class="studio-name">KuAtAmA Games</h2>
            <h1>GRAND TRAFFIC<br>RACER</h1>
            <h2>Nice City</h2>
        </div>
        <div id="loading-bar-container"><div id="loading-bar"></div></div>
        <div id="loading-percentage">0%</div>
        <div id="creator-credit">Created By Atakan Cerrahoğlu</div>
    </div>
    <div id="name-entry-screen">
        <h2>ISMINI GIR</h2>
        <input type="text" id="player-name-input" maxlength="12" placeholder="OYUNCU 1">
        <button id="start-game-button">OYUNA BASLA</button>
    </div>

    <canvas id="game"></canvas>
    <div id="ui-container">
        <div id="left-ui">
            <div id="wanted-level">
                <div id="star-1" class="star"></div><div id="star-2" class="star"></div><div id="star-3" class="star"></div><div id="star-4" class="star"></div><div id="star-5" class="star"></div>
            </div>
            <div id="health-bar-container"><div id="health-bar"></div></div>
        </div>
        <div id="right-ui">
             <div id="score" class="ui-text">SKOR: 0</div>
             <div id="money-display" class="ui-text">PARA: $0</div>
             <div id="nitro-display" class="ui-text">NİTRO: 0</div>
        </div>
    </div>

    <div id="mission-container">
        <div id="mission-text">Yeni bir gorev almak icin dugmeye bas!</div>
        <button id="generate-mission-btn">✨ Yeni Gorev Al</button>
    </div>

    <div id="radio-ticker-bar">
        <div id="radio-ticker-text"></div>
    </div>

    <div id="game-over-screen">
        <h1 id="game-over-text"></h1>
        <button onclick="location.reload()">Yeniden Basla</button>
    </div>
    <div id="mobile-controls">
        <div id="left-controls"><button id="brake-btn" class="control-btn">&darr;</button><button id="accel-btn" class="control-btn">&uarr;</button></div>
        <div id="right-controls"><button id="left-btn" class="control-btn">&larr;</button><button id="right-btn" class="control-btn">&rarr;</button></div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';

        // --- SABİTLER ---
        const SPEECH_BUBBLE_INTERVAL = 15;
        const ROAD_WIDTH = 20, SIDEWALK_WIDTH = 5, SEGMENT_LENGTH = 1000, SEGMENT_COUNT = 3, TOTAL_LENGTH = 3 * SEGMENT_LENGTH;
        const POLICE_BOOST_DISABLE_DURATION = 20;
        const POLICE_RAM_COOLDOWN = 10;
        const STAR_EMPTY_SVG = `<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="1.5"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.77 5.82 22 7 14.14l-5-4.87 6.91-1.01L12 2z"/></svg>`;
        const STAR_FILLED_SVG = `<svg viewBox="0 0 24 24" fill="#FFC700" stroke="#FDB813" stroke-width="1"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.77 5.82 22 7 14.14l-5-4.87 6.91-1.01L12 2z"/></svg>`;
        const NITRO_COST = 3000;

        const FALLBACK_MISSIONS = [
            "Polise yakalanmadan 2 dakika boyunca hayatta kal.", "Canın %50'nin altına düşmeden Şehir Merkezi'ne ulaş.", "Şehirdeki 3 heykeli yok et.",
            "Trafikteki 5 araca çarparak kaos yarat.", "Polis arabasını 3 başka araca çarptırarak büyük bir kaza yaptır.", "Okyanus Kenarı yolunda 30 saniye boyunca son sürat ilerle."
        ];
        const FALLBACK_CHATTER = [
            "Merkez, şüpheli Ocean Drive'da güneye doğru ilerliyor.", "Tüm birimlere: Kırmızı spor araba takibe alındı, destek bekleniyor.", "Şüpheli Downtown bölgesinde görüldü, aşırı hız yapıyor.",
            "Dikkat, şüpheli tehlikeli manevralar yapıyor. Dikkatli yaklaşın.", "Takip devam ediyor, şüpheli Starfish Adası'na yöneldi."
        ];

        const BUILDING_TYPES = [ 
            { type: 'shop', minFloors: 1, maxFloors: 2 }, 
            { type: 'club', minFloors: 1, maxFloors: 3 }, 
            { type: 'apartment', minFloors: 3, maxFloors: 8 }, 
            { type: 'hotel', minFloors: 9, maxFloors: 15 },
            { type: 'plaza', minFloors: 10, maxFloors: 20 }
        ];
        const NEON_COLORS = [0xff00ff, 0x00ffff, 0x54fcfd, 0xf72119, 0x00ff7f, 0xff89f3, 0xf38630, 0xfa6900];
        const WINDOW_LIGHT_COLORS = [0xffffee, 0xffd8b1, 0xcce4ff];
        const TRAFFIC_CAR_COLORS = [0xAAAAAA, 0xDDDDDD, 0x333333, 0x800000, 0x003300, 0xC0C0C0, 0xFF0000, 0x00FF00, 0x0000FF, 0xFFA500, 0x800080, 0x008080, 0xFF4500, 0xDA70D6, 0x4B0082, 0xADFF2F, 0x00FFFF];
        const VICE_CITY_COLORS = [0x2c002e, 0x6a005f, 0xff6a00, 0xffb861, 0xff89f3, 0x00ffff, 0xf72119, 0xf38630, 0xfa6900, 0xff4e50, 0xf9d423, 0xf8b195, 0xc06c84, 0x69d2e7, 0xa7dbd8];
        const dayCycleParameters = {
            NIGHT:     { background: new THREE.Color(0x1a2a4a), hemiSky: new THREE.Color(0xcceeff), hemiGround: new THREE.Color(0x556688), dirLight: new THREE.Color(0xffffff), dirIntensity: 0.6 },
            MORNING:   { background: new THREE.Color(0xf7b267), hemiSky: new THREE.Color(0xf7b267), hemiGround: new THREE.Color(0xc06c84), dirLight: new THREE.Color(0xffaa00), dirIntensity: 0.8 },
            PRE_NOON:  { background: new THREE.Color(0x87ceeb), hemiSky: new THREE.Color(0xadd8e6), hemiGround: new THREE.Color(0xa9a9a9), dirLight: new THREE.Color(0xffffff), dirIntensity: 1.0 },
            NOON:      { background: new THREE.Color(0x87ceeb), hemiSky: new THREE.Color(0xffffff), hemiGround: new THREE.Color(0xcccccc), dirLight: new THREE.Color(0xffffff), dirIntensity: 1.2 },
            AFTERNOON: { background: new THREE.Color(0xa0d8e9), hemiSky: new THREE.Color(0xf5f5dc), hemiGround: new THREE.Color(0xb0c7db), dirLight: new THREE.Color(0xffdd88), dirIntensity: 0.9 },
            EVENING:   { background: new THREE.Color(0xff4e50), hemiSky: new THREE.Color(0xff6f61), hemiGround: new THREE.Color(0x6b5b95), dirLight: new THREE.Color(0xff6600), dirIntensity: 0.7 }
        };
        const dayCyclePhases = ['NIGHT', 'MORNING', 'PRE_NOON', 'NOON', 'AFTERNOON', 'EVENING'];
        const dayCycleTime = 120; const phaseDuration = dayCycleTime / dayCyclePhases.length; let currentCycleTime = 0;

        // --- SES SABİTLERİ ---
        const MENU_VOLUME = 0.6; const RADIO_VOL_MAX = 0.6; const RADIO_VOL_MIN = 0.3;
        const ENGINE_VOL_MAX = 0.4; const ENGINE_VOL_MIN = 0.1; const SIREN_VOLUME = 0.5;

        // --- GLOBAL DEĞİŞKENLER ---
        let scene, camera, renderer, clock;
        let player, policeCar = null, sirenLightRed, sirenLightBlue, road;
        let nitroFlameLeft, nitroFlameRight;
        let sounds;
        let roadLines = [], buildings = [], palmTrees = [], guardRails = [], trafficCars = [], streetLights = [], statues = [], debrisParticles = [], rain, bulletSparks = [];
        let hemiLight, dirLight;
        let speed = 0, score = 0, wantedLevel = 0, playerHealth = 100, playerMoney = 0, nitroCharges = 0;
        let isGameOver = false, canBeCaught = false, isRaining = false, isRadioPlaying = false;
        let isAccelerating = false, isBraking = false, isTurningLeft = false, isTurningRight = false;
        let lastPoliceShotTime = 0, wantedLevelCooldown = 0, lastPoliceHitTime = 0, isCrashSoundPlaying = false;
        let beach, ocean, sidewalkLeft, sidewalkRight, buildingGround;
        let pedestrians = [];
        const PEDESTRIAN_SKIN_COLORS = ['#f2d5b1', '#c68642', '#8d5524', '#f5cba7', '#a16e4b'];
        const PEDESTRIAN_SHIRT_COLORS = [0x69d2e7, 0xa7dbd8, 0xf38630, 0xfa6900, 0xff4e50, 0xf9d423, 0xf8b195, 0xc06c84, 0xffffff, 0x333333];
        const PEDESTRIAN_PANTS_COLORS = [0x004d80, 0x333333, 'beige', 0x654321, 0x444444];
        let flyingDebris = [];
        let parkedCars = [], beachDetails = [], cityDecorations = [], sceneryObjects = [], waterMaterials = [];
        let citySkyline = [], seaSkyline = [], niceCitySign;
        let julieMissionTriggered = false;
        let preloadedPoliceCar = null;

        // --- SİNEMATİK DEĞİŞKENLERİ ---
        let isIntroPlaying = true;
        let cinematicCameraTarget;
        let isRampJumpingCinematic = false;
        let rampJumpCinematicTimer = 0;
        let cinematicRampCameraPos = new THREE.Vector3();

        const BOOST_CHARGE_TIME = 20, BOOST_DURATION = 3.5, SPECIAL_BOOST_DURATION = 7.0, BOOST_SPEED_MULTIPLIER = 1.6;
        let cleanDrivingTime = 0, isBoostAvailable = false, isBoosting = false, boostTimeRemaining = 0, lastAccelTapTime = 0, policeDisableTimer = 0;
        let hasPlayerMoved = false, policeSpawnTimer = -1, areHazardLightsOn = false, gameTime = 0;
        let nextChatterTime = 20, nextMissionPromptTime = 30, nextSpeechBubbleTime = 0;
        const CHATTER_INTERVAL = 25, MISSION_PROMPT_INTERVAL = 45;
        let missionHideTimeout = null, lastKeyUpTime = 0;
        const policePhrases = ["Dur! Saga cek!", "Kacabilecegini mi sandin?", "Bu is burada bitti!", "Teslim ol!", "Daha fazla zorluk cikarma!"];
        const playerPhrases = ["Haha, cok beklersin!", "Sikiysa yakala!", "Tozumu yut bakalim!", "Beni asla yakalayamazsiniz!", "Bu sehir benim!"];

        async function callGemini(prompt) {
            const isMissionPrompt = prompt.includes("görev hedefi oluştur");
            // *** ÖNEMLİ ***: Gemini API'yi kullanmak için kendi API anahtarınızı buraya girin.
            // Google AI Studio'dan ücretsiz bir anahtar alabilirsiniz.
            // Anahtar olmadan, oyun yedek görevleri ve telsiz konuşmalarını kullanacaktır.
            const apiKey = ""; // <--- KENDİ API ANAHTARINIZI BURAYA YAPIŞTIRIN
            if (!apiKey) {
                 console.warn("Gemini API anahtarı bulunamadı. Yedek içerik kullanılacak.");
                 return isMissionPrompt
                    ? FALLBACK_MISSIONS[Math.floor(Math.random() * FALLBACK_MISSIONS.length)]
                    : FALLBACK_CHATTER[Math.floor(Math.random() * FALLBACK_CHATTER.length)];
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                });
                if (!response.ok) { throw new Error(`API call failed with status: ${response.status}`); }
                const result = await response.json();
                if (result.candidates && result.candidates[0]?.content?.parts?.[0]) {
                    return result.candidates[0].content.parts[0].text.trim();
                } else { throw new Error("API yanıtında geçerli bir aday bulunamadı."); }
            } catch (error) {
                console.error("Gemini API çağrı hatası:", error.message);
                return isMissionPrompt
                    ? FALLBACK_MISSIONS[Math.floor(Math.random() * FALLBACK_MISSIONS.length)]
                    : FALLBACK_CHATTER[Math.floor(Math.random() * FALLBACK_CHATTER.length)];
            }
        }

        function displayError(e) {
            const errorDisplay = document.getElementById('error-display');
            if (errorDisplay) {
                errorDisplay.style.display = 'block';
                errorDisplay.innerHTML = `<h1>OYUN HATASI!</h1><p>Uzgunuz, oyunda beklenmedik bir hata olustu.</p><p><strong>Hata Adi:</strong> ${e.name}</p><p><strong>Mesaj:</strong> ${e.message}</p><hr><p><strong>Teknik Detay (Stack Trace):</strong></p><pre>${e.stack}</pre>`;
            }
        }

        function loadSounds() {
            // Not: GitHub'dan ham dosya çekmek CORS sorunlarına neden olabilir.
            // Ses dosyalarını projenizle aynı klasöre koyup yerel olarak çağırmak en iyisidir.
            // Örn: src: ['./sounds/engine.ogg']
            sounds = {
                engine: new Howl({ src: ['https://github.com/atakancerrahoglu/Nice-city/raw/main/engine_sound.ogg'], loop: true, volume: ENGINE_VOL_MIN, html5: true }),
                crash: new Howl({ src: ['https://actions.google.com/sounds/v1/impacts/crash.ogg'], volume: 0.5 }),
                siren: new Howl({ src: ['https://github.com/atakancerrahoglu/Nice-city/raw/main/police_sound.ogg'], loop: true, volume: SIREN_VOLUME, html5: true }),
                radio: new Howl({ src: ['https://github.com/atakancerrahoglu/Nice-city/raw/main/Vice%20City%20Geceleri.mp3'], loop: true, volume: MENU_VOLUME, html5: true }),
                // 404 veren ses dosyası çalışan bir alternatif ile değiştirildi.
                heal_sound: new Howl({ src: ['https://actions.google.com/sounds/v1/foley/cassette_tape_button_press.ogg'], volume: 0.7 }),
                nitro_gain: new Howl({ src: ['https://actions.google.com/sounds/v1/alarms/digital_watch_alarm_long.ogg'], volume: 0.6 })
            };
        }

        function loadAssets() {
            const loadingBar = document.getElementById('loading-bar');
            const loadingPercentage = document.getElementById('loading-percentage');
            let progress = 0;

            // Performans için polis arabasını oyun başında yükle
            preloadedPoliceCar = createPoliceCar(true);

            const interval = setInterval(() => {
                progress += 2;
                if(progress > 100) progress = 100;
                loadingBar.style.width = progress + '%';
                loadingPercentage.innerText = Math.round(progress) + '%';
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        document.getElementById('loading-screen').style.opacity = '0';
                        const nameEntryScreen = document.getElementById('name-entry-screen');
                        nameEntryScreen.style.display = 'flex';
                        setTimeout(() => nameEntryScreen.classList.add('visible'), 50);
                        nameEntryScreen.addEventListener('transitionend', () => {
                            document.getElementById('loading-screen').style.display = 'none';
                        }, { once: true });
                    }, 500);
                }
            }, 50);
        }

        function setupGameStart() {
            const startGameButton = document.getElementById('start-game-button');
            const nameEntryScreen = document.getElementById('name-entry-screen');
            const playerNameInput = document.getElementById('player-name-input');
            playerNameInput.addEventListener('focus', () => {
                if (!isRadioPlaying && sounds?.radio) {
                    sounds.radio.play(); isRadioPlaying = true;
                }
            }, { once: true });
            startGameButton.addEventListener('click', () => {
                if (isRadioPlaying && sounds?.radio) {
                    sounds.radio.fade(MENU_VOLUME, RADIO_VOL_MAX, 1000);
                }
                nameEntryScreen.classList.remove('visible');
                setTimeout(() => {
                    nameEntryScreen.style.display = 'none';
                    initializeGame();
                }, 1000);
            });
        }

        function onWindowResize() {
            if (camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }
            if (renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        function createWorld() {
            createRoadAndSidewalks();
            createRoadLines();
            createStreetLights();
            createPlayer();
            createRain();
            createScenery();
        }

        function createPlayer() {
            player = new THREE.Group();

            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xD40000, flatShading: true });
            const secondaryMaterial = new THREE.MeshPhongMaterial({ color: 0x222222, flatShading: true });
            const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, transparent: true, opacity: 0.8, flatShading: true });
            // HATA DÜZELTMESİ: MeshBasicMaterial yerine MeshStandardMaterial kullanıldı.
            const lightMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF88, emissive: 0xFFFF88, emissiveIntensity: 1.5 });
            const taillightMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, emissive: 0xFF0000, emissiveIntensity: 1.8 });

            const mainBody = new THREE.Mesh(new THREE.BoxGeometry(3.0, 0.6, 6.0), bodyMaterial);
            mainBody.position.y = 0.6; mainBody.castShadow = true; player.add(mainBody);
            const frontHood = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.3, 2.0), bodyMaterial);
            frontHood.position.set(0, 0.7, -3.0); player.add(frontHood);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.5, 2.5), bodyMaterial);
            cabin.position.set(0, 1.0, 0.5); player.add(cabin);
            const windshield = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.3, 0.1), windowMaterial);
            windshield.position.set(0, 1.2, -0.7); player.add(windshield);
            const rearWindow = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.3, 0.1), windowMaterial);
            rearWindow.position.set(0, 1.2, 1.7); player.add(rearWindow);
            const rearDeck = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.3, 2.0), bodyMaterial);
            rearDeck.position.set(0, 0.7, 3.0); player.add(rearDeck);
            const spoiler = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.1, 0.6), secondaryMaterial);
            spoiler.position.set(0, 1.0, 4.2); player.add(spoiler);
            const diffuser = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.3, 0.2), secondaryMaterial);
            diffuser.position.set(0, 0.2, 3.0); player.add(diffuser);

            // HATA DÜZELTMESİ: Işıklar doğrudan atanıyor.
            const headlight1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.1), lightMaterial);
            headlight1.position.set(-1.2, 0.6, -3.01);
            const headlight2 = headlight1.clone();
            headlight2.position.x = 1.2;
            
            const taillight1 = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.3, 0.1), taillightMaterial);
            taillight1.position.set(-0.6, 0.6, 4.01);
            const taillight2 = taillight1.clone();
            taillight2.position.x = 0.6;

            player.add(headlight1, headlight2, taillight1, taillight2);
            player.userData.lights = {headlight1, headlight2, taillight1, taillight2};

            const wheelGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 16);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x111111, flatShading: true });
            const createWheel = () => { const w = new THREE.Mesh(wheelGeom, wheelMaterial); w.rotation.z = Math.PI / 2; return w; };
            const wFL = createWheel(); wFL.position.set(-1.6, 0.5, -2.0);
            const wFR = createWheel(); wFR.position.set(1.6, 0.5, -2.0);
            const wBL = createWheel(); wBL.position.set(-1.6, 0.5, 2.0);
            const wBR = createWheel(); wBR.position.set(1.6, 0.5, 2.0);
            player.add(wFL, wFR, wBL, wBR);

            nitroFlameLeft = createNitroFlame();
            nitroFlameLeft.position.set(-0.8, 0.5, 3.2);
            player.add(nitroFlameLeft);

            nitroFlameRight = createNitroFlame();
            nitroFlameRight.position.set(0.8, 0.5, 3.2);
            player.add(nitroFlameRight);

            player.position.set(ROAD_WIDTH / 2 - 2, 0, 5);
            player.rotation.y = -Math.PI / 16;
            
            player.userData.isJumping = false;
            player.userData.verticalVelocity = 0;
            scene.add(player);
        }

        function createPoliceCarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#004d26';
            ctx.fillRect(0, 0, 128, 256);

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 50, 128, 80);

            ctx.font = "bold 30px Arial";
            ctx.fillStyle = '#004d26';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("POLICE", 64, 90);

            ctx.fillStyle = '#111111';
            ctx.fillRect(10, 140, 108, 50);

            return new THREE.CanvasTexture(canvas);
        }

        function createPoliceCar(isPreload = false) {
            const car = new THREE.Group();

            const policeTexture = createPoliceCarTexture();
            const bodyMaterial = new THREE.MeshPhongMaterial({ map: policeTexture, flatShading: true });

            const blackTrimMaterial = new THREE.MeshPhongMaterial({ color: 0x111111, flatShading: true });
            const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x222222, transparent: true, opacity: 0.7 });
            // HATA DÜZELTMESİ: MeshBasicMaterial yerine MeshStandardMaterial
            const taillightMaterial = new THREE.MeshStandardMaterial({ color: 0xbb0000, emissive: 0xbb0000, emissiveIntensity: 1.5 });
            const headlightMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF88, emissive: 0xFFFF88, emissiveIntensity: 1.0 });

            const mainBody = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.7, 5.4), bodyMaterial);
            mainBody.position.y = 0.7; car.add(mainBody);

            const cabin = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.6, 2.5), bodyMaterial);
            cabin.position.set(0, 1.3, -0.3); car.add(cabin);

            const windshield = new THREE.Mesh(new THREE.PlaneGeometry(2.1, 0.65), windowMaterial);
            windshield.position.set(0, 1.3, -1.55); windshield.rotation.x = -Math.PI / 8; car.add(windshield);

            const rearWindow = new THREE.Mesh(new THREE.PlaneGeometry(2.1, 0.65), windowMaterial);
            rearWindow.position.set(0, 1.3, 0.95); rearWindow.rotation.x = Math.PI / 9; car.add(rearWindow);

            const hood = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.5, 2.0), bodyMaterial);
            hood.position.set(0, 0.65, -2.2); car.add(hood);

            const trunk = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.4, 1.5), bodyMaterial);
            trunk.position.set(0, 0.6, 2.0); car.add(trunk);

            const taillightGeo = new THREE.BoxGeometry(1.2, 0.35, 0.1);
            const leftTaillight = new THREE.Mesh(taillightGeo, taillightMaterial);
            leftTaillight.position.set(-0.65, 0.7, 2.75);
            const rightTaillight = new THREE.Mesh(taillightGeo, taillightMaterial);
            rightTaillight.position.set(0.65, 0.7, 2.75);
            car.add(leftTaillight, rightTaillight);

            const sirenBase = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.05, 0.5), blackTrimMaterial);
            sirenBase.position.set(0, 1.6, -0.3); car.add(sirenBase);
            const sirenLightGeo = new THREE.BoxGeometry(0.5, 0.25, 0.5);
            const localSirenLightRed = new THREE.Mesh(sirenLightGeo, new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0 }));
            localSirenLightRed.position.set(-0.3, 1.7, -0.3);
            const localSirenLightBlue = new THREE.Mesh(sirenLightGeo, new THREE.MeshStandardMaterial({ color: 0x0000ff, emissive: 0x0000ff, emissiveIntensity: 0 }));
            localSirenLightBlue.position.set(0.3, 1.7, -0.3);
            car.add(localSirenLightRed, localSirenLightBlue);

            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x111111, flatShading: true });
            const createWheel = () => new THREE.Mesh(wheelGeometry, wheelMaterial);
            const wFL = createWheel(); wFL.rotation.z = Math.PI / 2; wFL.position.set(-1.3, 0.4, -1.6);
            const wFR = createWheel(); wFR.rotation.z = Math.PI / 2; wFR.position.set(1.3, 0.4, -1.6);
            const wBL = createWheel(); wBL.rotation.z = Math.PI / 2; wBL.position.set(-1.3, 0.4, 1.8);
            const wBR = createWheel(); wBR.rotation.z = Math.PI / 2; wBR.position.set(1.3, 0.4, 1.8);
            car.add(wFL, wFR, wBL, wBR);

            const policeHeadlight1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.1), headlightMaterial);
            policeHeadlight1.position.set(-1.0, 0.7, -2.51);
            const policeHeadlight2 = policeHeadlight1.clone();
            policeHeadlight2.position.x = 1.0;
            car.add(policeHeadlight1, policeHeadlight2);
            
            // HATA DÜZELTMESİ: Işıklar userData'ya doğrudan atanıyor.
            car.userData.lights = { 
                headlight1: policeHeadlight1, 
                headlight2: policeHeadlight2, 
                taillight1: leftTaillight, 
                taillight2: rightTaillight,
                sirenRed: localSirenLightRed,
                sirenBlue: localSirenLightBlue
            };

            if (isPreload) {
                return car;
            }
            
            policeCar = car;
            sirenLightRed = localSirenLightRed; // Global değişkenler hala kullanılabilir
            sirenLightBlue = localSirenLightBlue;

            policeCar.position.set(player.position.x, 0, player.position.z + 50); 
            policeCar.rotation.y = Math.PI; 
            policeCar.userData.health = 100;
            policeCar.userData.aiState = 'following';
            policeCar.userData.aiTimer = Math.random() * 3 + 4;
            scene.add(policeCar);
        }

        function spawnPoliceCar() {
            if (policeCar || !preloadedPoliceCar) return;
            
            policeCar = preloadedPoliceCar;
            
            // Işık referanslarını global değişkenlere ata
            sirenLightRed = policeCar.userData.lights.sirenRed;
            sirenLightBlue = policeCar.userData.lights.sirenBlue;

            policeCar.position.set(player.position.x, 0, player.position.z + 50); 
            policeCar.rotation.y = Math.PI; 
            policeCar.userData.health = 100;
            policeCar.userData.aiState = 'following';
            policeCar.userData.aiTimer = Math.random() * 3 + 4;
            
            scene.add(policeCar);
        }

        function createPedestrianTexture(config) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = config.skinColor;
            ctx.fillRect(22, 0, 20, 20);
            ctx.fillRect(12, 20, 40, 50);
            ctx.fillRect(12, 70, 18, 58);
            ctx.fillRect(34, 70, 18, 58);

            ctx.fillStyle = '#222';
            ctx.fillRect(22, 0, 20, 8);

            ctx.fillStyle = new THREE.Color(config.shirtColor).getStyle();
            ctx.fillRect(12, 22, 40, 35);

            ctx.fillStyle = new THREE.Color(config.pantsColor).getStyle();
            ctx.fillRect(12, 70, 40, 40);

            return new THREE.CanvasTexture(canvas);
        }

        function createPedestrian() {
            const config = {
                skinColor: PEDESTRIAN_SKIN_COLORS[Math.floor(Math.random() * PEDESTRIAN_SKIN_COLORS.length)],
                shirtColor: PEDESTRIAN_SHIRT_COLORS[Math.floor(Math.random() * PEDESTRIAN_SHIRT_COLORS.length)],
                pantsColor: PEDESTRIAN_PANTS_COLORS[Math.floor(Math.random() * PEDESTRIAN_PANTS_COLORS.length)]
            };

            const texture = createPedestrianTexture(config);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });

            const geometry = new THREE.PlaneGeometry(1.2, 2.4);
            const pedestrian = new THREE.Mesh(geometry, material);
            pedestrian.position.y = 1.2;
            return pedestrian;
        }

        function createFlyingDebris() {
            const debrisMaterial = new THREE.MeshBasicMaterial({
                color: 0xcccccc,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const debrisGeometry = new THREE.PlaneGeometry(0.5, 0.5);
            const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);

            debris.userData.velocity = new THREE.Vector3( (Math.random() - 0.5) * 0.1, Math.random() * 0.05 + 0.02, (Math.random() - 0.5) * 0.1 );
            debris.userData.rotationSpeed = new THREE.Vector3( (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1 );
            return debris;
        }

        function createBuildingTexture(width, height, floors, type) {
            const canvas = document.createElement('canvas');
            const aspectRatio = height / width;
            canvas.width = 256; // Fixed width for better performance
            canvas.height = Math.max(128, 256 * aspectRatio); // Ensure a minimum height
            const ctx = canvas.getContext('2d');
            
            const wallColor = new THREE.Color(VICE_CITY_COLORS[Math.floor(Math.random() * VICE_CITY_COLORS.length)]).getStyle();
            const accentColor = new THREE.Color(VICE_CITY_COLORS[Math.floor(Math.random() * VICE_CITY_COLORS.length)]).getStyle();
            
            ctx.fillStyle = wallColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = accentColor;
            for(let i=0; i < 10; i++) {
                if (Math.random() > 0.5)
                    ctx.fillRect(Math.random() * canvas.width, 0, 5 + Math.random() * 10, canvas.height);
            }

            const windowWidth = 10;
            const windowHeight = 15;
            const horizontalSpacing = 20;
            const verticalSpacing = 25;
            const numCols = Math.floor(canvas.width / horizontalSpacing);

            const isNight = ['NIGHT', 'EVENING'].includes(dayCyclePhases[Math.floor(currentCycleTime / phaseDuration)]);

            for (let f = 0; f < floors * 2; f++) {
                for (let i = 0; i < numCols; i++) {
                    const x = (i * horizontalSpacing) + 10;
                    const y = (f * verticalSpacing) + 15;
                    
                    if (y > canvas.height - windowHeight) continue;

                    if (isNight && Math.random() > 0.3) {
                         ctx.fillStyle = new THREE.Color(WINDOW_LIGHT_COLORS[Math.floor(Math.random()*WINDOW_LIGHT_COLORS.length)]).getStyle();
                    } else {
                         ctx.fillStyle = '#222244';
                    }
                    ctx.fillRect(x, y, windowWidth, windowHeight);
                }
            }
            
            if (isNight && (type === 'club' || type === 'hotel' || Math.random() < 0.2)) {
                const neonColor = new THREE.Color(NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)]).getStyle();
                ctx.font = `bold ${Math.max(20, canvas.width / 8)}px 'Bebas Neue', sans-serif`;
                ctx.textAlign = 'center';
                ctx.shadowColor = neonColor;
                ctx.shadowBlur = 15;
                ctx.fillStyle = neonColor;
                
                let text = "BAR";
                if(type === 'hotel') text = "HOTEL";
                if(type === 'club') text = ["MALIBU", "VIBE", "NEON", "CLUB"][Math.floor(Math.random()*4)];
                if(type === 'plaza') text = "PLAZA";
                
                ctx.fillText(text, canvas.width / 2, canvas.height * (0.3 + Math.random() * 0.4));
                ctx.shadowBlur = 0;
            }


            return new THREE.CanvasTexture(canvas);
        }

        function createGroundTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#666';
            ctx.fillRect(0, 0, 128, 128);

            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;

            for(let i = 0; i < 128; i += 32) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 128);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(128, i);
                ctx.stroke();
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createParkedCarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 64;
            const ctx = canvas.getContext('2d');

            const carColor = TRAFFIC_CAR_COLORS[Math.floor(Math.random() * TRAFFIC_CAR_COLORS.length)];
            ctx.fillStyle = new THREE.Color(carColor).getStyle();

            ctx.beginPath();
            ctx.moveTo(5, 50);
            ctx.lineTo(123, 50);
            ctx.lineTo(110, 30);
            ctx.lineTo(20, 30);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#55aaff';
            ctx.beginPath();
            ctx.moveTo(30, 30);
            ctx.lineTo(90, 30);
            ctx.lineTo(80, 15);
            ctx.lineTo(40, 15);
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        function createCityDecoration(type) {
            const canvas = document.createElement('canvas');
            const material = new THREE.MeshBasicMaterial({ transparent: true, side: THREE.DoubleSide });
            let geometry;

            if (type === 'nightclub') {
                canvas.width = 256; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.font = "bold 48px 'Bebas Neue', sans-serif";
                ctx.fillStyle = '#ff00ff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 20;
                ctx.fillText("MALIBU CLUB", canvas.width / 2, canvas.height / 2);
                geometry = new THREE.PlaneGeometry(12, 6);
            }

            material.map = new THREE.CanvasTexture(canvas);
            const decoration = new THREE.Mesh(geometry, material);
            decoration.position.y = 10;
            return decoration;
        }

        function createBeachDetail(type) {
            const canvas = document.createElement('canvas');
            const material = new THREE.MeshBasicMaterial({ transparent: true, side: THREE.DoubleSide });
            let geometry;

            if (type === 'towel') {
                canvas.width = 64; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = VICE_CITY_COLORS[Math.floor(Math.random() * VICE_CITY_COLORS.length)];
                ctx.fillRect(0,0,64,128);
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillRect(0,10,64,10);
                ctx.fillRect(0,108,64,10);
                geometry = new THREE.PlaneGeometry(2, 4);
            }

            material.map = new THREE.CanvasTexture(canvas);
            const detail = new THREE.Mesh(geometry, material);
            detail.rotation.x = -Math.PI / 2;
            return detail;
        }

        function createAmbulance() {
            const ambulance = new THREE.Group();
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF, flatShading: true });
            const stripeMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000, flatShading: true });
            const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, transparent: true, opacity: 0.8, flatShading: true });
            const headlightMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF88, emissive: 0xFFFF88, emissiveIntensity: 1.0 });
            const taillightMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, emissive: 0xFF0000, emissiveIntensity: 1.0 });

            const mainBody = new THREE.Mesh(new THREE.BoxGeometry(2.8, 1.6, 6.5), bodyMaterial);
            mainBody.position.y = 1.6 / 2 + 0.1;
            ambulance.add(mainBody);

            const cab = new THREE.Mesh(new THREE.BoxGeometry(2.6, 1.4, 2.0), bodyMaterial);
            cab.position.set(0, 1.6 + 1.4 / 2 - 0.2, -2.25);
            ambulance.add(cab);

            const windshield = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.8, 0.1), windowMaterial);
            windshield.position.set(0, 1.6 + 1.4 - 0.2, -3.2);
            ambulance.add(windshield);

            const sideStripeGeo = new THREE.BoxGeometry(0.1, 0.4, 5.0);
            const leftStripe = new THREE.Mesh(sideStripeGeo, stripeMaterial);
            leftStripe.position.set(-1.41, 1.0, 0);
            ambulance.add(leftStripe);
            const rightStripe = leftStripe.clone();
            rightStripe.position.x = 1.41;
            ambulance.add(rightStripe);

            const roofLightGeo = new THREE.BoxGeometry(0.3, 0.2, 0.5);
            const roofLightMaterialBlue = new THREE.MeshStandardMaterial({ color: 0x0000ff, emissive: 0x0000ff, emissiveIntensity: 0 });
            const roofLightMaterialRed = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0 });
            const roofLight1 = new THREE.Mesh(roofLightGeo, roofLightMaterialBlue);
            roofLight1.position.set(-0.4, 1.6 + 1.6 - 0.1, 0);
            const roofLight2 = new THREE.Mesh(roofLightGeo, roofLightMaterialRed);
            roofLight2.position.set(0.4, 1.6 + 1.6 - 0.1, 0);
            ambulance.add(roofLight1, roofLight2);

            const headlight1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.1), headlightMaterial);
            headlight1.position.set(-1.0, 1.2, -3.21);
            const headlight2 = headlight1.clone();
            headlight2.position.x = 1.0;
            ambulance.add(headlight1, headlight2);

            const taillight1 = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.3, 0.1), taillightMaterial);
            taillight1.position.set(-0.6, 1.2, 3.21);
            const taillight2 = taillight1.clone();
            taillight2.position.x = 0.6;
            ambulance.add(taillight1, taillight2);

            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x111111, flatShading: true });
            const createWheel = () => { const w = new THREE.Mesh(wheelGeometry, wheelMaterial); w.rotation.z = Math.PI / 2; return w; };
            const wFL = createWheel(); wFL.position.set(-1.4, 0.5, -2.0);
            const wFR = createWheel(); wFR.position.set(1.4, 0.5, -2.0);
            const wBL = createWheel(); wBL.position.set(-1.4, 0.5, 2.0);
            const wBR = createWheel(); wBR.position.set(1.4, 0.5, 2.0);
            ambulance.add(wFL, wFR, wBL, wBR);

            ambulance.userData.type = 'ambulance';
            ambulance.userData.speed = 1.0 + Math.random() * 0.2;
            ambulance.userData.healedPlayer = false;
            ambulance.userData.lights = { headlight1, headlight2, taillight1, taillight2, roofLight1, roofLight2 };
            return ambulance;
        }

        function createArmoredTruckTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#666666';
            ctx.fillRect(0, 0, 128, 128);

            ctx.fillStyle = '#555555';
            ctx.fillRect(0, 30, 128, 68);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = 'bold 20px Bebas Neue';
            ctx.textAlign = 'center';
            ctx.fillText('SECURITY', 64, 80);

            return new THREE.CanvasTexture(canvas);
        }

        function createArmoredTruck() {
            const truck = createAmbulance();

            const armoredTexture = createArmoredTruckTexture();
            const armoredMaterial = new THREE.MeshStandardMaterial({
                 map: armoredTexture,
                 metalness: 0.8,
                 roughness: 0.4,
                 flatShading: true,
            });

            truck.children.forEach(child => {
                if (child.isMesh) {
                    if (child.geometry.type === 'BoxGeometry') {
                         child.material = armoredMaterial;
                    }
                }
            });

            truck.userData.type = 'armored_truck';
            truck.userData.speed = 0.8 + Math.random() * 0.2;
            return truck;
        }


        function updatePlayerMovement() {
            if (isIntroPlaying || isRampJumpingCinematic) return;

            const topSpeed = 5.5;
            if (isBoosting) {
                const boostTargetSpeed = topSpeed * BOOST_SPEED_MULTIPLIER;
                speed = Math.min(boostTargetSpeed, speed + 0.25);
            } else {
                if(isAccelerating) { speed = Math.min(topSpeed, speed + 0.08); }
                else if(isBraking) { speed = Math.max(0, speed - 0.1); }
                else { speed *= 0.99; }
            }
            if (!hasPlayerMoved && speed > 0.1) {
                hasPlayerMoved = true;
                areHazardLightsOn = false;
                policeSpawnTimer = 10;
            }
            const turnSpeed = speed > 0.5 ? 0.25 : 0;
            const limitLeft = -ROAD_WIDTH / 2 - SIDEWALK_WIDTH + 1.7;
            const limitRight = ROAD_WIDTH / 2 + SIDEWALK_WIDTH - 1.7;
            if(isTurningLeft) player.position.x = Math.max(limitLeft, player.position.x - turnSpeed);
            if(isTurningRight) player.position.x = Math.min(limitRight, player.position.x + turnSpeed);

            let targetTilt = 0;
            if (isTurningLeft) targetTilt = 0.1;
            else if (isTurningRight) targetTilt = -0.1;
            player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, targetTilt, 0.08);
            player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, 0, 0.05);
        }

        function startGame() {
            wantedLevel = 1; updateStarsUI(); lastPoliceShotTime = 0; lastPoliceHitTime = 0; canBeCaught = true;
            if(sounds.siren && !sounds.siren.playing()) sounds.siren.play();
            setTimeout(() => { showSpeechBubble('police', 'Dur! Sağa çek!'); }, 1500);
            setTimeout(() => { showSpeechBubble('player', 'Haha, çok beklersin!'); }, 3000);
            nextSpeechBubbleTime = clock.getElapsedTime() + SPEECH_BUBBLE_INTERVAL;
        }

        function createRoadLines() {
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700 });
            const lineGeometry = new THREE.PlaneGeometry(0.5, SEGMENT_LENGTH);
            const laneOffset = ROAD_WIDTH / 6;

            for (let i = 0; i < SEGMENT_COUNT; i++) {
                const segmentZ = i * SEGMENT_LENGTH - TOTAL_LENGTH / 2 + SEGMENT_LENGTH / 2;

                const lineLeft = new THREE.Mesh(lineGeometry, lineMaterial);
                lineLeft.rotation.x = -Math.PI / 2;
                lineLeft.position.set(-laneOffset, 0.02, segmentZ);
                roadLines.push(lineLeft);
                road.add(lineLeft);

                const lineRight = new THREE.Mesh(lineGeometry, lineMaterial);
                lineRight.rotation.x = -Math.PI / 2;
                lineRight.position.set(laneOffset, 0.02, segmentZ);
                roadLines.push(lineRight);
                road.add(lineRight);
            }
        }

        function createBuilding(x, z, isWall = false) {
            const bD = BUILDING_TYPES[Math.floor(Math.random() * BUILDING_TYPES.length)];
            const nF = bD.minFloors + Math.floor(Math.random() * (bD.maxFloors - bD.minFloors + 1));
            const bH = nF * 5; 
            const bW = isWall ? 40 + Math.random() * 20 : 15 + Math.random() * 10; 
            const bDe = isWall ? 0.5 : 15 + Math.random() * 10;

            const buildingTexture = createBuildingTexture(bW, bH, nF, bD.type);
            buildingTexture.wrapS = THREE.RepeatWrapping;
            buildingTexture.wrapT = THREE.RepeatWrapping;
            buildingTexture.repeat.set(1, 1);

            const bG = new THREE.BoxGeometry(bW, bH, bDe);
            const buildingMaterial = new THREE.MeshPhongMaterial({
                map: buildingTexture,
                flatShading: true
            });

            const bMe = new THREE.Mesh(bG, buildingMaterial); bMe.castShadow = true; bMe.receiveShadow = true;
            const bGr = new THREE.Group(); bGr.add(bMe);
            
            const isNight = ['NIGHT', 'EVENING'].includes(dayCyclePhases[Math.floor(currentCycleTime / phaseDuration)]);
            if (isNight && !isWall && (bD.type === 'club' || bD.type === 'hotel' || Math.random() < 0.2)) {
                const neonColor = NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)];
                const pL = new THREE.PointLight(neonColor, 3, 50, 2); 
                pL.position.set(0, bH * 0.6, bDe/2 + 1); 
                bGr.add(pL);
            }

            bGr.position.set(x, bH / 2, z); buildings.push(bGr); scene.add(bGr);
        }

        function moveWorld(currentSpeed){
            [...buildings, ...palmTrees, ...guardRails, ...trafficCars, ...streetLights, ...statues, ...pedestrians, ...flyingDebris, ...parkedCars, ...beachDetails, ...cityDecorations, ...sceneryObjects, ...citySkyline, ...seaSkyline, niceCitySign].forEach(o=>{
                if (!o) return;
                o.position.z += currentSpeed;
                if(o.position.z > player.position.z + SEGMENT_LENGTH * 1.5) {
                    o.position.z -= TOTAL_LENGTH;
                }
            });
            road.children.forEach(c => { c.position.z += currentSpeed; if(c.position.z > player.position.z + SEGMENT_LENGTH/2) c.position.z -= SEGMENT_COUNT * SEGMENT_LENGTH; });
            sidewalkLeft.children.forEach(c => { c.position.z += currentSpeed; if(c.position.z > player.position.z + SEGMENT_LENGTH/2) c.position.z -= SEGMENT_COUNT * SEGMENT_LENGTH; });
            sidewalkRight.children.forEach(c => { c.position.z += currentSpeed; if(c.position.z > player.position.z + SEGMENT_LENGTH/2) c.position.z -= SEGMENT_COUNT * SEGMENT_LENGTH; });
            buildingGround.children.forEach(c => { c.position.z += currentSpeed; if(c.position.z > player.position.z + SEGMENT_LENGTH/2) c.position.z -= SEGMENT_COUNT * SEGMENT_LENGTH; });
            beach.children.forEach(c => { c.position.z += currentSpeed; if(c.position.z > player.position.z + SEGMENT_LENGTH/2) c.position.z -= SEGMENT_COUNT * SEGMENT_LENGTH; });
            ocean.children.forEach(c => { c.position.z += currentSpeed; if(c.position.z > player.position.z + SEGMENT_LENGTH/2) c.position.z -= SEGMENT_COUNT * SEGMENT_LENGTH; });
            roadLines.forEach(l => {
                l.position.z += currentSpeed;
                if (l.position.z > player.position.z + SEGMENT_LENGTH/2) l.position.z -= SEGMENT_COUNT * SEGMENT_LENGTH;
            });
        }


        function updatePoliceShooting(dT){
            if(wantedLevel < 2 || !policeCar || policeDisableTimer > 0) return;
            lastPoliceShotTime += dT; const shotInterval = 6 - wantedLevel * 0.8;
            if(lastPoliceShotTime > shotInterval){
                lastPoliceShotTime = 0; takeDamage(wantedLevel * 2); createBulletSparks(player);
                const hB = document.getElementById('health-bar'); hB.classList.add('damaged');
                setTimeout(() => hB.classList.remove('damaged'), 200); shakeCamera(0.2 + wantedLevel * 0.05);
            }
        }

        function takeDamage(amount, reason = "WASTED"){
            if (isGameOver) return;
            playerHealth -= amount;
            updateHealth();
            if(playerHealth <= 0){ endGame(reason); }
        }

        function updateHealth() {
            playerHealth = Math.max(0, Math.min(100, playerHealth));
            const healthBar = document.getElementById('health-bar');
            if (healthBar) {
                healthBar.style.width = playerHealth + '%';
                if (playerHealth > 50) {
                    healthBar.style.backgroundColor = '#4CAF50';
                } else if (playerHealth > 20) {
                    healthBar.style.backgroundColor = '#FFC107';
                } else {
                    healthBar.style.backgroundColor = '#f44336';
                }
            }
        }

        function updateTraffic(dT){
            if(trafficCars.length < 15 && Math.random() < 0.03 && hasPlayerMoved) createTrafficCar();
            for(let i = trafficCars.length - 1; i >= 0; i--){
                const car = trafficCars[i];
                if(car.userData.isHit){
                    car.position.add(car.userData.velocity.clone().multiplyScalar(dT)); car.rotation.y += car.userData.spin * dT;
                    car.userData.velocity.y -= 9.8 * dT; car.userData.life -= dT;
                    if(car.userData.life <= 0){ scene.remove(car); trafficCars.splice(i, 1); }
                } else { car.position.z += car.userData.speed * 0.5; }
                if(car.position.z > player.position.z + 50 || car.position.z < player.position.z - 500){ scene.remove(car); trafficCars.splice(i, 1); }
            }
        }

        function checkRampJumps() {
            if (!player || player.userData.isJumping || isRampJumpingCinematic) return;

            const playerBox = new THREE.Box3().setFromObject(player);

            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const car = trafficCars[i];
                if (car.userData.type !== 'ramp_truck') continue;

                const rampMesh = car.userData.rampMesh;
                if (!rampMesh) continue;

                const rampBox = new THREE.Box3().setFromObject(rampMesh);

                if (playerBox.intersectsBox(rampBox)) {
                     if (speed > 2.5) {
                        player.userData.isJumping = true;
                        player.userData.verticalVelocity = 25;
                        score += 2500;
                        showSpeechBubble('player', 'Hadi Uçalım!');

                        isRampJumpingCinematic = true;
                        rampJumpCinematicTimer = 2.0;
                        cinematicRampCameraPos.set(player.position.x - 20, player.position.y + 10, player.position.z);

                        return;
                    }
                }
            }
        }

        function checkCollisions(){
            if(!canBeCaught || !player || isRampJumpingCinematic) return;
            const playerBoundingBox = new THREE.Box3().setFromObject(player);
            for(let i = trafficCars.length - 1; i >= 0; i--){
                const trafficCar = trafficCars[i];
                if(trafficCar.userData.isHit || trafficCar.userData.type === 'ambulance' || trafficCar.userData.type === 'ramp_truck') continue;

                const carBoundingBox = new THREE.Box3().setFromObject(trafficCar);
                if(playerBoundingBox.intersectsBox(carBoundingBox)){
                    if(trafficCar.userData.type === 'armored_truck') {
                        takeDamage(20);
                        playerMoney += 1000;
                        if (playerMoney >= NITRO_COST) {
                            const chargesGained = Math.floor(playerMoney / NITRO_COST);
                            nitroCharges += chargesGained;
                            playerMoney -= chargesGained * NITRO_COST;
                            showSpeechBubble('player', `+${chargesGained} Nitro Hakki!`);
                            if(sounds.nitro_gain) sounds.nitro_gain.play();
                        }
                        updatePlayerHUD();
                        trafficCar.position.z += 0.5;
                        speed *= 0.5;
                        shakeCamera(0.6);
                    } else {
                        if(!isCrashSoundPlaying){
                            isCrashSoundPlaying = true; if(sounds && sounds.crash) sounds.crash.play();
                            setTimeout(() => { isCrashSoundPlaying = false; }, 110);
                        }
                        createDebris(trafficCar.position); trafficCar.userData.isHit = true; trafficCar.userData.life = 2.0;
                        const impactDirection = new THREE.Vector3().subVectors(trafficCar.position, player.position).normalize();
                        trafficCar.userData.velocity = impactDirection.multiplyScalar(15 + speed).add(new THREE.Vector3(0, 3, 0));
                        trafficCar.userData.spin = (Math.random() - 0.5) * 10;
                        speed *= 0.2; takeDamage(4); cleanDrivingTime = 0; isBoostAvailable = false; updateBoostUI();
                        lastPoliceShotTime = 0; shakeCamera(0.4); score += 500; updatePlayerHUD();
                        if(wantedLevel < 5 && wantedLevelCooldown <= 0) { wantedLevel++; updateStarsUI(); wantedLevelCooldown = 3; }
                    }
                    break;
                }
            }
        }

        function checkPoliceCollisions() {
            if (!policeCar) return;
            const policeBoundingBox = new THREE.Box3().setFromObject(policeCar);
            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const trafficCar = trafficCars[i]; if (trafficCar.userData.isHit) continue;
                const carBoundingBox = new THREE.Box3().setFromObject(trafficCar);
                if (policeBoundingBox.intersectsBox(carBoundingBox)) {
                    policeCar.userData.health -= 10;
                    const impactDirection = new THREE.Vector3().subVectors(trafficCar.position, policeCar.position).normalize();
                    trafficCar.userData.velocity = impactDirection.multiplyScalar(10).add(new THREE.Vector3(0, 2, 0));
                    trafficCar.userData.spin = (Math.random() - 0.5) * 5;
                    trafficCar.userData.isHit = true; trafficCar.userData.life = 2.0;
                    if (policeCar.userData.health <= 0) { scene.remove(policeCar); policeCar = null; return; }
                    break;
                }
            }
        }

        function checkDestructibleCollisions() {
            if (!player || isRampJumpingCinematic) return;
            const playerBox = new THREE.Box3().setFromObject(player);
            for (let i = statues.length - 1; i >= 0; i--) {
                const statue = statues[i];
                if (statue.userData.isHit) continue;
                const statueBox = new THREE.Box3().setFromObject(statue);
                if (playerBox.intersectsBox(statueBox)) {
                    statue.userData.isHit = true;
                    createDebris(statue.position);
                    scene.remove(statue);
                    statues.splice(i, 1);
                    takeDamage(5); speed *= 0.8; score += 1000; updatePlayerHUD(); shakeCamera(0.5);
                    if(sounds && sounds.crash) sounds.crash.play();
                    cleanDrivingTime = 0; isBoostAvailable = false; updateBoostUI();
                }
            }
            for (let i = streetLights.length - 1; i >= 0; i--) {
                const light = streetLights[i];
                if (light.userData.isHit) continue;
                const lightBox = new THREE.Box3().setFromObject(light.children[0]);
                lightBox.expandByVector(new THREE.Vector3(0,4,0));
                lightBox.applyMatrix4(light.matrixWorld);
                if (playerBox.intersectsBox(lightBox)) {
                    light.userData.isHit = true;
                    light.userData.isFalling = true;
                    light.userData.fallRotation = 0;
                    light.userData.fallAxis = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                    takeDamage(10); speed *= 0.7; score += 250; updatePlayerHUD(); shakeCamera(0.6);
                    if(sounds && sounds.crash) sounds.crash.play();
                    cleanDrivingTime = 0; isBoostAvailable = false; updateBoostUI();
                }
            }
        }

        function shakeCamera(intensity = 0.3){
            let shakeAmount = intensity;
            const shakeInterval = setInterval(() => {
                camera.position.x += (Math.random() - 0.5) * shakeAmount;
                camera.position.y += (Math.random() - 0.5) * shakeAmount;
                shakeAmount *= 0.8;
                if(shakeAmount < 0.05) { clearInterval(shakeInterval); }
            }, 20);
        }

        function endGame(reason){
            isGameOver = true;
            if (sounds && sounds.siren) sounds.siren.stop(); if (sounds && sounds.engine) sounds.engine.stop(); if (sounds && sounds.radio) sounds.radio.stop();
            const gameOverText = document.getElementById('game-over-text');
            const finalReason = reason === "YAKALANDIN" ? "YAKALANDIN" : "WASTED";
            gameOverText.innerText = finalReason; gameOverText.style.color = (finalReason === "WASTED") ? "#d9534f" : "#5bc0de";
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        function createTrafficCar(forceType = null, position = null) {
            let chosenType = forceType;
            if (!chosenType) {
                const vehicleTypes = ['sedan', 'convertible', 'motorcycle', 'chopper', 'limousine', 'ramp_truck', 'ambulance', 'armored_truck'];
                const typeWeights =  [0.25, 0.15, 0.10, 0.10, 0.05, 0.10, 0.15, 0.10];
                let randomValue = Math.random(); let cumulativeWeight = 0;
                for (let i = 0; i < vehicleTypes.length; i++) { cumulativeWeight += typeWeights[i]; if (randomValue < cumulativeWeight) { chosenType = vehicleTypes[i]; break; } }
            }

            let vehicle;
            switch (chosenType) {
                case 'sedan': vehicle = createLuxurySedan(); break;
                case 'convertible': vehicle = createConvertible(); break;
                case 'motorcycle': vehicle = createMotorcycle(); break;
                case 'chopper': vehicle = createChopper(); break;
                case 'limousine': vehicle = createLimousine(); break;
                case 'ramp_truck': vehicle = createRampTruck(); break;
                case 'ambulance': vehicle = createAmbulance(); break;
                case 'armored_truck': vehicle = createArmoredTruck(); break;
            }

            if(position) {
                vehicle.position.copy(position);
            } else {
                if (chosenType === 'ramp_truck') {
                    vehicle.position.x = ROAD_WIDTH / 2 + SIDEWALK_WIDTH - 3;
                } else {
                    const lanes = [-ROAD_WIDTH / 3, 0, ROAD_WIDTH / 3];
                    vehicle.position.x = lanes[Math.floor(Math.random() * lanes.length)];
                }
                vehicle.position.z = player.position.z - 300 - Math.random() * 400;
            }
            
            // Işıklar zaten araç oluşturma fonksiyonlarında userData'ya eklendiği için
            // burada tekrar eklemeye gerek yok.

            trafficCars.push(vehicle); scene.add(vehicle);

            if (chosenType === 'ramp_truck' && Math.random() < 0.4) {
                 const blockerPos = vehicle.position.clone();
                 blockerPos.z -= 15 + Math.random() * 10;
                 createTrafficCar('sedan', blockerPos);
            }
        }

        function createLuxurySedan() {
            const car = new THREE.Group();
            const material = new THREE.MeshPhongMaterial({ color: TRAFFIC_CAR_COLORS[Math.floor(Math.random() * TRAFFIC_CAR_COLORS.length)], flatShading: true });
            const headlightMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF88, emissive: 0xFFFF88, emissiveIntensity: 1.0 });
            const taillightMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, emissive: 0xFF0000, emissiveIntensity: 1.0 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.9, 5.5), material); body.position.y = 0.9; car.add(body);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.7, 2.5), material); cabin.position.set(0, 1.65, -0.4); car.add(cabin);
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 12); const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
            function createWheel() { const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial); wheel.rotation.z = Math.PI / 2; return wheel; }
            const wFL = createWheel(); wFL.position.set(-1.2, 0.4, -1.8); const wFR = createWheel(); wFR.position.set(1.2, 0.4, -1.8);
            const wBL = createWheel(); wBL.position.set(-1.2, 0.4, 1.8); const wBR = createWheel(); wBR.position.set(1.2, 0.4, 1.8);
            car.add(wFL, wFR, wBL, wBR); 
            
            const headlight1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.1), headlightMaterial);
            headlight1.position.set(-1.0, 0.7, -2.51);
            const headlight2 = headlight1.clone();
            headlight2.position.x = 1.0;
            const taillight1 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 0.1), taillightMaterial);
            taillight1.position.set(-0.7, 0.7, 2.51);
            const taillight2 = taillight1.clone();
            taillight2.position.x = 0.7;
            car.add(headlight1, headlight2, taillight1, taillight2);
            car.userData.lights = { headlight1, headlight2, taillight1, taillight2 };

            car.userData.speed = 1.4 + Math.random() * 0.5; 
            return car;
        }

        function createConvertible() {
            const car = new THREE.Group(); 
            const material = new THREE.MeshPhongMaterial({ color: TRAFFIC_CAR_COLORS[Math.floor(Math.random() * TRAFFIC_CAR_COLORS.length)], flatShading: true });
            const headlightMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF88, emissive: 0xFFFF88, emissiveIntensity: 1.0 });
            const taillightMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, emissive: 0xFF0000, emissiveIntensity: 1.0 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.7, 4.8), material); body.position.y = 0.75; car.add(body);
            const seatMaterial = new THREE.MeshPhongMaterial({ color: 0x552211 }); const seat1 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 0.8), seatMaterial); seat1.position.set(0, 1.1, 0.5);
            const seat2 = seat1.clone(); seat2.position.z = -0.5; car.add(seat1, seat2);
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 12); const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
            function createWheel() { const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial); wheel.rotation.z = Math.PI / 2; return wheel; }
            const wFL = createWheel(); wFL.position.set(-1.2, 0.4, -1.5); const wFR = createWheel(); wFR.position.set(1.2, 0.4, -1.5);
            const wBL = createWheel(); wBL.position.set(-1.2, 0.4, 1.5); const wBR = createWheel(); wBR.position.set(1.2, 0.4, 1.5);
            car.add(wFL, wFR, wBL, wBR); 
            
            const headlight1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.1), headlightMaterial);
            headlight1.position.set(-0.9, 0.7, -2.41);
            const headlight2 = headlight1.clone(); headlight2.position.x = 0.9;
            const taillight1 = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.2, 0.1), taillightMaterial);
            taillight1.position.set(-0.7, 0.7, 2.41);
            const taillight2 = taillight1.clone(); taillight2.position.x = 0.7;
            car.add(headlight1, headlight2, taillight1, taillight2);
            car.userData.lights = { headlight1, headlight2, taillight1, taillight2 };

            car.userData.speed = 1.8 + Math.random() * 0.5; return car;
        }

        function createMotorcycle() {
            const bike = new THREE.Group(); 
            const material = new THREE.MeshPhongMaterial({ color: TRAFFIC_CAR_COLORS[Math.floor(Math.random() * TRAFFIC_CAR_COLORS.length)], flatShading: true });
            const headlightMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF88, emissive: 0xFFFF88, emissiveIntensity: 1.0 });
            const taillightMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, emissive: 0xFF0000, emissiveIntensity: 1.0 });
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.5, 1.8), material); body.position.y = 0.7; bike.add(body);
            const wheelGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.2, 12);
            const frontWheel = new THREE.Mesh(wheelGeometry, material); frontWheel.rotation.x = Math.PI / 2; frontWheel.position.set(0, 0.35, -0.9);
            const rearWheel = frontWheel.clone(); rearWheel.position.z = 0.9; bike.add(frontWheel, rearWheel);

            const headlight1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.1, 16), headlightMaterial);
            headlight1.position.set(0, 0.8, -0.95);
            const taillight1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.05), taillightMaterial);
            taillight1.position.set(0, 0.7, 0.95);
            bike.add(headlight1, taillight1);
            // Motosikletin sadece birer farı ve stop lambası olduğu için headlight2 ve taillight2'yi null yapabiliriz.
            bike.userData.lights = { headlight1, headlight2: null, taillight1, taillight2: null };

            bike.userData.speed = 2.2 + Math.random() * 0.8; return bike;
        }

        function createChopper() {
            const bike = createMotorcycle(); // Temel olarak aynı, sadece parçalar farklı
            return bike;
        }

        function createLimousine() {
            const limo = new THREE.Group(); 
            const material = new THREE.MeshPhongMaterial({ color: TRAFFIC_CAR_COLORS[Math.floor(Math.random() * TRAFFIC_CAR_COLORS.length)], flatShading: true });
            const headlightMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF88, emissive: 0xFFFF88, emissiveIntensity: 1.0 });
            const taillightMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, emissive: 0xFF0000, emissiveIntensity: 1.0 });

            const mainBody = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.9, 10.0), material); mainBody.position.y = 0.9; limo.add(mainBody);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.8, 3.0), material); cabin.position.set(0, 1.7, -2.5); limo.add(cabin);
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 12); const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
            function createWheel() { const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial); wheel.rotation.z = Math.PI / 2; return wheel; }
            const wheelFL = createWheel(); wheelFL.position.set(-1.3, 0.4, -4.0); const wheelFR = createWheel(); wheelFR.position.set(1.3, 0.4, -4.0);
            const wheelBL = createWheel(); wheelBL.position.set(-1.3, 0.4, 4.0); const wheelBR = createWheel(); wheelBR.position.set(1.3, 0.4, 4.0);
            limo.add(wheelFL, wheelFR, wheelBL, wheelBR); 

            const headlight1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.1), headlightMaterial);
            headlight1.position.set(-1.1, 0.7, -5.01);
            const headlight2 = headlight1.clone(); headlight2.position.x = 1.1;
            const taillight1 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 0.1), taillightMaterial);
            taillight1.position.set(-1.0, 0.7, 5.01);
            const taillight2 = taillight1.clone(); taillight2.position.x = 1.0;
            limo.add(headlight1, headlight2, taillight1, taillight2);
            limo.userData.lights = { headlight1, headlight2, taillight1, taillight2 };

            limo.userData.speed = 1.2 + Math.random() * 0.3; return limo;
        }

        function createRampTruck() {
            const truck = new THREE.Group();
            const cabMaterial = new THREE.MeshPhongMaterial({ color: 0x00A0B0, flatShading: true });
            const flatbedMaterial = new THREE.MeshPhongMaterial({ color: 0xFFC300, flatShading: true });
            const rampMaterial = new THREE.MeshPhongMaterial({ color: 0xFF5733, flatShading: true });

            const cab = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.2, 2.5), cabMaterial);
            cab.position.set(0, 1.1, -4.0);
            truck.add(cab);

            const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x222222, transparent: true, opacity: 0.7 });
            const windshield = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1, 0.1), windowMaterial);
            windshield.position.set(0, 1.5, -5.24);
            truck.add(windshield);

            const flatbed = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.5, 9), flatbedMaterial);
            flatbed.position.set(0, 0.6, 1);
            truck.add(flatbed);

            const rampGeometry = new THREE.BoxGeometry(2.4, 0.3, 7);
            const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
            ramp.position.set(0, 1.0, 2);
            ramp.rotation.x = -Math.PI / 12;
            truck.add(ramp);

            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 12);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
            function createWheel() { const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial); wheel.rotation.z = Math.PI / 2; return wheel; }
            const wheelFL = createWheel(); wheelFL.position.set(-1.3, 0.5, -3.5);
            const wheelFR = createWheel(); wheelFR.position.set(1.3, 0.5, -3.5);
            const wheelBL1 = createWheel(); wheelBL1.position.set(-1.3, 0.5, 2.5);
            const wheelBR1 = createWheel(); wheelBR1.position.set(1.3, 0.5, 2.5);
            const wheelBL2 = createWheel(); wheelBL2.position.set(-1.3, 0.5, 4.0);
            const wheelBR2 = createWheel(); wheelBR2.position.set(1.3, 0.5, 4.0);
            truck.add(wheelFL, wheelFR, wheelBL1, wheelBR1, wheelBL2, wheelBR2);
            
            truck.userData.lights = {}; // Bu aracın standart farları yok
            truck.userData.type = 'ramp_truck';
            truck.userData.speed = 1.0 + Math.random() * 0.2;
            truck.userData.rampMesh = ramp;
            return truck;
        }

        function createDebris(position){
            const debrisCount = 5 + Math.floor(Math.random() * 5);
            const debrisMaterial = new THREE.MeshBasicMaterial({color:0x555555});
            const debrisGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            for(let i = 0; i < debrisCount; i++){
                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial.clone());
                debris.position.copy(position);
                debris.userData.velocity = new THREE.Vector3((Math.random() - 0.5) * 5, Math.random() * 4, (Math.random() - 0.5) * 5);
                debris.userData.life = 1.5;
                debrisParticles.push(debris);
                scene.add(debris);
            }
        }

        function updateDebris(deltaTime){
            for(let i = debrisParticles.length - 1; i >= 0; i--){
                const debris = debrisParticles[i]; debris.userData.life -= deltaTime * 1.5;
                if(debris.userData.life <= 0){ scene.remove(debris); debrisParticles.splice(i, 1);
                } else {
                    debris.position.add(debris.userData.velocity.clone().multiplyScalar(deltaTime));
                    debris.material.opacity = debris.userData.life; debris.material.transparent = true;
                }
            }
        }

        function createBulletSparks(targetObject) {
            const sparkCount = 3 + Math.floor(Math.random() * 3);
            const sparkMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00, transparent: true });
            const sparkGeometry = new THREE.PlaneGeometry(0.1, 0.1);
            const targetBox = new THREE.Box3().setFromObject(targetObject);
            const targetSize = targetBox.getSize(new THREE.Vector3());
            for (let i = 0; i < sparkCount; i++) {
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial.clone());
                const randomPos = new THREE.Vector3((Math.random() - 0.5) * targetSize.x, (Math.random() - 0.5) * targetSize.y, (Math.random() - 0.5) * targetSize.z);
                spark.position.copy(targetObject.position).add(randomPos); spark.userData.velocity = randomPos.normalize().multiplyScalar(2); spark.userData.life = 0.3;
                bulletSparks.push(spark); scene.add(spark);
            }
        }

        function updateBulletSparks(deltaTime) {
            for (let i = bulletSparks.length - 1; i >= 0; i--) {
                const spark = bulletSparks[i]; spark.userData.life -= deltaTime;
                if (spark.userData.life <= 0) { scene.remove(spark); bulletSparks.splice(i, 1);
                } else {
                    spark.position.add(spark.userData.velocity.clone().multiplyScalar(deltaTime));
                    spark.material.opacity = spark.userData.life / 0.3;
                }
            }
        }

        function updatePoliceAI(deltaTime) {
            if (!policeCar || !canBeCaught || isRampJumpingCinematic) return;
            if (policeDisableTimer > 0) {
                const targetZ = player.position.z + 150;
                const targetPosition = new THREE.Vector3(player.position.x, policeCar.position.y, targetZ);
                policeCar.position.lerp(targetPosition, 0.02); return;
            }
            policeCar.userData.aiTimer -= deltaTime;
            let targetZ, alpha = 0.08;
            switch(policeCar.userData.aiState) {
                case 'following':
                    targetZ = player.position.z + 15 + Math.sin(gameTime) * 3; alpha = 0.05;
                    if (policeCar.userData.aiTimer <= 0) { policeCar.userData.aiState = 'preparing'; policeCar.userData.aiTimer = 1.5; }
                    break;
                case 'preparing':
                     targetZ = player.position.z + 25; alpha = 0.03;
                     if (policeCar.userData.aiTimer <= 0) { policeCar.userData.aiState = 'ramming'; policeCar.userData.aiTimer = 2; }
                    break;
                case 'ramming':
                    targetZ = player.position.z + 3; alpha = 0.15;
                    if (policeCar.userData.aiTimer <= 0) { policeCar.userData.aiState = 'following'; policeCar.userData.aiTimer = Math.random() * 4 + 5; }
                    break;
            }
            const targetPosition = new THREE.Vector3(player.position.x, policeCar.position.y, targetZ);
            policeCar.position.lerp(targetPosition, alpha);
            const policeBoundingBox = new THREE.Box3().setFromObject(policeCar);
            const playerBoundingBox = new THREE.Box3().setFromObject(player);
            if (policeBoundingBox.intersectsBox(playerBoundingBox) && policeCar.position.z < player.position.z + 5) {
                if (clock.elapsedTime - lastPoliceHitTime > 1.0) {
                    takeDamage(15, "YAKALANDIN");
                    lastPoliceHitTime = clock.elapsedTime; shakeCamera(0.4);
                    player.position.z -= 0.5; policeCar.position.z += 1.0; speed *= 0.7;
                    policeCar.userData.aiState = 'following'; policeCar.userData.aiTimer = Math.random() * 4 + 5;
                }
            }
        }

        function updateCamera(){
            if (!player || isIntroPlaying) return;

            if (isRampJumpingCinematic) {
                camera.position.lerp(cinematicRampCameraPos, 0.05);
                const lookAtTarget = new THREE.Vector3(player.position.x, player.position.y + 2.0, player.position.z);
                camera.lookAt(lookAtTarget);
                return;
            }

            const speedFactor = Math.min(speed / 5.5, 1.0); const cameraTarget = new THREE.Vector3();
            cameraTarget.x = player.position.x * 0.6;
            cameraTarget.y = player.position.y + 12 - (speedFactor * 2);
            cameraTarget.z = player.position.z + 25 - (speedFactor * 5);
            camera.position.lerp(cameraTarget, 0.08);
            const lookAtTarget = new THREE.Vector3(player.position.x, player.position.y + 2.0, player.position.z);
            camera.lookAt(lookAtTarget);
        }

        function updatePlayerHUD() {
            document.getElementById('score').innerText = `SKOR: ${Math.floor(score)}`;
            document.getElementById('money-display').innerText = `PARA: $${playerMoney}`;
            document.getElementById('nitro-display').innerText = `NİTRO: ${nitroCharges}`;
        }


        function updateStarsUI(){ for(let i = 1; i <= 5; i++) document.getElementById(`star-${i}`).innerHTML = (i <= wantedLevel) ? STAR_FILLED_SVG : STAR_EMPTY_SVG; }

        function updateBoostUI() {
            const accelBtn = document.getElementById('accel-btn');
            if (nitroCharges > 0) {
                accelBtn.innerHTML = `NİTRO`;
                accelBtn.style.fontSize = '18px';
                accelBtn.classList.add('nitro-ready');
            } else if (isBoostAvailable) {
                accelBtn.innerHTML = 'IVME';
                accelBtn.style.fontSize = '18px';
                accelBtn.classList.remove('nitro-ready');
            } else {
                accelBtn.innerHTML = '&uarr;';
                accelBtn.style.fontSize = '38px';
                accelBtn.classList.remove('nitro-ready');
            }
        }

        function showSpeechBubble(character, message) {
            const bubbleId = character === 'player' ? 'player-speech-bubble' : 'police-speech-bubble';
            const bubble = document.getElementById(bubbleId); if (!bubble || bubble.classList.contains('visible')) return;
            bubble.innerText = message || (character === 'player' ? playerPhrases[Math.floor(Math.random() * playerPhrases.length)] : policePhrases[Math.floor(Math.random() * policePhrases.length)]);
            bubble.style.display = 'block'; setTimeout(() => bubble.classList.add('visible'), 10);
            setTimeout(() => { bubble.classList.remove('visible'); setTimeout(() => bubble.style.display = 'none', 300); }, 2500);
        }

        function setupControls(){
            const accelBtn = document.getElementById('accel-btn');
            const brakeBtn = document.getElementById('left-btn'); // Corrected from brake-btn
            const leftBtn = document.getElementById('left-btn');
            const rightBtn = document.getElementById('right-btn');

            const triggerBoost = () => {
                 if (nitroCharges > 0) {
                    isBoosting = true;
                    boostTimeRemaining = SPECIAL_BOOST_DURATION;
                    nitroCharges--;
                    updatePlayerHUD();
                    updateBoostUI();
                 } else if (isBoostAvailable) {
                    isBoosting = true;
                    isBoostAvailable = false;
                    boostTimeRemaining = BOOST_DURATION;
                    policeDisableTimer = POLICE_BOOST_DISABLE_DURATION;
                    cleanDrivingTime = 0;
                    updateBoostUI();
                }
            }

            const onKeyDown = e => {
                if (isIntroPlaying) return;
                if(e.code === 'ArrowUp' || e.code === 'KeyW') {
                    if(!isAccelerating && clock){
                        const now = clock.getElapsedTime();
                        if (now - lastKeyUpTime < 0.3) { triggerBoost(); }
                    }
                    isAccelerating = true;
                }
                if(e.code === 'ArrowDown' || e.code === 'KeyS') isBraking = true;
                if(e.code === 'ArrowLeft' || e.code === 'KeyA') isTurningLeft = true;
                if(e.code === 'ArrowRight' || e.code === 'KeyD') isTurningRight = true;
            };
            const onKeyUp = e => {
                if (isIntroPlaying) return;
                if(e.code === 'ArrowUp' || e.code === 'KeyW') {
                    isAccelerating = false;
                    if(clock) lastKeyUpTime = clock.getElapsedTime();
                }
                if(e.code === 'ArrowDown' || e.code === 'KeyS') isBraking = false;
                if(e.code === 'ArrowLeft' || e.code === 'KeyA') isTurningLeft = false;
                if(e.code === 'ArrowRight' || e.code === 'KeyD') isTurningRight = false;
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            const handleAccelStart = () => {
                if (isIntroPlaying) return;
                isAccelerating = true; if (!clock) return; const now = clock.getElapsedTime();
                if (now - lastAccelTapTime < 0.3) { triggerBoost(); }
                lastAccelTapTime = now;
            };
            const handleAccelEnd = () => {
                if (isIntroPlaying) return;
                isAccelerating = false; lastAccelTapTime = clock.getElapsedTime();
            };

            const addTouchListeners = (element, startCallback, endCallback) => {
                const onStart = e => { e.preventDefault(); if (isIntroPlaying) return; startCallback(); };
                const onEnd = e => { e.preventDefault(); if (isIntroPlaying) return; endCallback(); };
                element.addEventListener('touchstart', onStart, { passive: false });
                element.addEventListener('touchend', onEnd);
                element.addEventListener('mousedown', onStart);
                element.addEventListener('mouseup', onEnd);
                element.addEventListener('mouseleave', onEnd);
            };

            addTouchListeners(accelBtn, handleAccelStart, handleAccelEnd);
            addTouchListeners(document.getElementById('brake-btn'), () => isBraking = true, () => isBraking = false);
            addTouchListeners(leftBtn, () => isTurningLeft = true, () => isTurningLeft = false);
            addTouchListeners(rightBtn, () => isTurningRight = true, () => isTurningRight = false);
        }

        async function generateMission() {
            if (julieMissionTriggered) return;
            if (missionHideTimeout) clearTimeout(missionHideTimeout);
            const missionContainer = document.getElementById('mission-container');
            const missionText = document.getElementById('mission-text');
            const missionBtn = document.getElementById('generate-mission-btn');
            missionBtn.disabled = true; missionText.innerText = "Yeni görev oluşturuluyor..."; missionBtn.innerHTML = '✨ Bekleyin...';
            const prompt = `Vice City benzeri bir şehirde geçen bir polis kovalamaca oyunu için kısa ve heyecan verici bir görev hedefi oluştur. Oyuncu kaçan kişidir. Görev tek bir cümle olmalı ve Türkçe olmalı. Yıkılabilir heykeller veya aydınlatma direkleri gibi yeni oyun mekaniklerini de içerebilir.
            Örnekler:
            - 2 dakikadan az sürede 50.000 dolarlık mülk hasarı ver.
            - Canın %50'nin altına düşmeden Şehir Merkezi'ne ulaş.
            - Şehirdeki 3 heykeli yok et.
            - 5 aydınlatma direğini devir.
            - Polis arabasını 5 başka araca çarptırarak büyük bir kaza yaptır.
            Şimdi yeni ve benzersiz bir görev oluştur:`;
            const newMission = await callGemini(prompt);
            missionText.innerText = newMission;
            missionBtn.disabled = false; missionBtn.innerHTML = '✨ Yeni Görev Al';
            if (!missionContainer.classList.contains('visible')) {
                 missionContainer.style.display = 'flex';
                 setTimeout(() => missionContainer.classList.add('visible'), 10);
            }
            missionHideTimeout = setTimeout(() => {
                missionContainer.classList.remove('visible');
                missionContainer.addEventListener('transitionend', () => { if (!missionContainer.classList.contains('visible')) missionContainer.style.display = 'none' }, { once: true });
            }, 4000);
        }

        async function generateRadioChatter() {
            const tickerBar = document.getElementById('radio-ticker-bar');
            const tickerText = document.getElementById('radio-ticker-text');
            if (!tickerBar || !tickerText || !player || tickerBar.classList.contains('visible')) return;
            const locations = ["Ocean Drive", "Downtown", "Little Havana", "Starfish Island", "Viceport"];
            const currentLocation = locations[Math.floor(Math.random() * locations.length)];
            const speedKph = Math.floor(speed * 30);
            const prompt = `Bir araba kovalamaca oyunu için kısa ve gerçekçi bir polis telsizi anonsu oluştur. Mesaj Türkçe olmalı ve en fazla iki kısa cümleden oluşmalı.
            Bağlam: Aranma seviyesi: ${wantedLevel} yıldız. Hız: yaklaşık ${speedKph} km/s. Konum: ${currentLocation}. Araç: Kırmızı spor araba.
            Örnek: "Merkez, şüpheli ${currentLocation} bölgesinde güneye ilerliyor. Teyit edildi, takipteyiz."
            Yeni bir anons oluştur:`;
            const chatter = await callGemini(prompt);
            tickerText.innerText = `[TELSİZ]: ${chatter}`;
            tickerBar.classList.add('visible');
            tickerText.style.animation = 'none';
            tickerText.offsetHeight;
            tickerText.style.animation = 'ticker-scroll 15s linear';
            setTimeout(() => { tickerBar.classList.remove('visible'); }, 14500);
        }

        function createMarbleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = `hsl(0, 0%, ${70 + Math.random() * 25}%)`;
            ctx.fillRect(0, 0, 256, 256);

            for (let i = 0; i < 15; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * 256, Math.random() * 256);
                ctx.lineTo(Math.random() * 256, Math.random() * 256);
                ctx.strokeStyle = `rgba(0, 0, 0, ${0.1 + Math.random() * 0.2})`;
                ctx.lineWidth = 1 + Math.random() * 5;
                ctx.stroke();
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createNormalMapFromHeight(heightCanvas, strength) {
            const ctx = heightCanvas.getContext('2d');
            const width = heightCanvas.width;
            const height = heightCanvas.height;
            const srcData = ctx.getImageData(0, 0, width, height).data;

            const normalCanvas = document.createElement('canvas');
            normalCanvas.width = width;
            normalCanvas.height = height;
            const normCtx = normalCanvas.getContext('2d');
            const destImage = normCtx.createImageData(width, height);
            const destData = destImage.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const g_x1 = srcData[((y * width + (x - 1 + width) % width) * 4)] / 255;
                    const g_x2 = srcData[((y * width + (x + 1) % width) * 4)] / 255;
                    const g_y1 = srcData[((((y - 1 + height) % height) * width + x) * 4)] / 255;
                    const g_y2 = srcData[(((y + 1) % height * width + x) * 4)] / 255;

                    const v = new THREE.Vector3( (g_x1 - g_x2) * strength, (g_y1 - g_y2) * strength, 1.0 ).normalize();

                    const i = (y * width + x) * 4;
                    destData[i] = (v.x + 1.0) * 127.5;
                    destData[i + 1] = (v.y + 1.0) * 127.5;
                    destData[i + 2] = v.z * 255.0;
                    destData[i + 3] = 255;
                }
            }
            normCtx.putImageData(destImage, 0, 0);
            return new THREE.CanvasTexture(normalCanvas);
        }

        function createMonument() {
            const monument = new THREE.Group();

            const colorTexture = createMarbleTexture();
            const normalTexture = createNormalMapFromHeight(colorTexture.image, 1.5);

            const mat = new THREE.MeshStandardMaterial({
                map: colorTexture,
                normalMap: normalTexture,
                roughness: 0.4,
                metalness: 0.1,
                flatShading: true
            });

            const type = Math.random();
            if (type < 0.5) { // Obelisk
                const baseHeight = 1 + Math.random();
                const base = new THREE.Mesh(new THREE.BoxGeometry(4, baseHeight, 4), mat);
                base.position.y = baseHeight / 2;
                monument.add(base);

                const shaftHeight = 8 + Math.random() * 8;
                const shaftGeo = new THREE.CylinderGeometry(1.5, 0.5, shaftHeight, 4, 1, false);
                const shaft = new THREE.Mesh(shaftGeo, mat);
                shaft.position.y = baseHeight + shaftHeight / 2;
                shaft.rotation.y = Math.PI / 4;
                monument.add(shaft);
            } else { // Abstract
                const numParts = 3 + Math.floor(Math.random() * 3);
                let currentY = 0;
                for (let i = 0; i < numParts; i++) {
                    const partHeight = 2 + Math.random() * 4;
                    const partWidth = 1 + Math.random() * 5;
                    const partDepth = 1 + Math.random() * 5;
                    const partGeo = new THREE.BoxGeometry(partWidth, partHeight, partDepth);
                    const part = new THREE.Mesh(partGeo, mat);
                    part.position.set((Math.random() - 0.5) * 2, currentY + partHeight / 2, (Math.random() - 0.5) * 2);
                    part.rotation.y = Math.random() * Math.PI;
                    monument.add(part);
                    currentY += partHeight * 0.8;
                }
            }

            monument.castShadow = true;
            monument.userData.isStatue = true;
            monument.userData.isHit = false;
            return monument;
        }

        function createPoolPark() {
            const park = new THREE.Group();
            const parkSize = 18 + Math.random() * 10;

            const groundMat = new THREE.MeshStandardMaterial({ color: '#a7dbd8', roughness: 0.8 });
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(parkSize, parkSize), groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0.1;
            park.add(ground);

            const poolSize = parkSize * (0.4 + Math.random() * 0.3);
            const poolBasinMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.6 });
            const poolBasin = new THREE.Mesh(new THREE.BoxGeometry(poolSize, 0.5, poolSize), poolBasinMat);
            poolBasin.position.y = 0.25;
            park.add(poolBasin);

            const waterNormalMap = createWaterNormalMap();
            waterNormalMap.wrapS = THREE.RepeatWrapping;
            waterNormalMap.wrapT = THREE.RepeatWrapping;

            const waterMat = new THREE.MeshStandardMaterial({
                color: 0x55aaff,
                metalness: 0.3,
                roughness: 0.1,
                transparent: true,
                opacity: 0.85,
                normalMap: waterNormalMap,
                normalScale: new THREE.Vector2(0.3, 0.3)
            });
            waterMaterials.push(waterMat);

            const water = new THREE.Mesh(new THREE.PlaneGeometry(poolSize - 0.5, poolSize - 0.5), waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0.45;
            park.add(water);

            park.userData.isPark = true;
            return park;
        }

        function createWaterNormalMap() {
            const canvas = document.createElement('canvas');
            const size = 128;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(size, size);
            const data = imageData.data;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;
                    const angle = (Math.sin(x * 0.1) + Math.cos(y * 0.1)) * Math.PI;
                    data[i] = (Math.cos(angle) * 0.5 + 0.5) * 255;
                    data[i + 1] = (Math.sin(angle) * 0.5 + 0.5) * 255;
                    data[i + 2] = 255;
                    data[i + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            return new THREE.CanvasTexture(canvas);
        }

        function updateFallingObjects(deltaTime) {
            for (let i = streetLights.length - 1; i >= 0; i--) {
                const light = streetLights[i];
                if (light.userData.isFalling && light.userData.fallRotation < Math.PI / 2) {
                    light.userData.fallRotation += deltaTime * 2;
                    light.rotation.x = light.userData.fallRotation;
                    if(policeCar) {
                         const polePart = light.children[0];
                         const poleBox = new THREE.Box3().setFromObject(polePart);
                         poleBox.applyMatrix4(light.matrixWorld);
                         const policeBox = new THREE.Box3().setFromObject(policeCar);
                         if(poleBox.intersectsBox(policeBox)) {
                             if(!light.userData.hasDamagedPolice) {
                                policeCar.userData.health -= 35;
                                createBulletSparks(policeCar);
                                light.userData.hasDamagedPolice = true;
                                if(policeCar.userData.health <= 0) {
                                    createDebris(policeCar.position);
                                    scene.remove(policeCar); policeCar = null;
                                }
                             }
                         }
                    }
                }
            }
        }

        function createNitroFlame() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(173, 216, 230, 1)'); // LightBlue
            gradient.addColorStop(0.4, 'rgba(0, 191, 255, 0.8)'); // DeepSkyBlue
            gradient.addColorStop(1, 'rgba(0, 0, 255, 0)'); // Blue to transparent
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true
            });

            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.8, 2.5, 1);
            sprite.visible = false;
            return sprite;
        }

        function updateNitroFlames() {
            if (isBoosting) {
                nitroFlameLeft.visible = true;
                nitroFlameRight.visible = true;
                const scaleFactor = 1 + Math.sin(clock.getElapsedTime() * 50) * 0.2;
                nitroFlameLeft.scale.y = 2.5 * scaleFactor;
                nitroFlameRight.scale.y = 2.5 * scaleFactor;
                nitroFlameLeft.material.opacity = 0.8 + Math.random() * 0.2;
                nitroFlameRight.material.opacity = 0.8 + Math.random() * 0.2;
            } else {
                nitroFlameLeft.visible = false;
                nitroFlameRight.visible = false;
            }
        }


        function updateDayCycle(deltaTime) {
            currentCycleTime = (currentCycleTime + deltaTime) % dayCycleTime;
            const currentPhaseIndex = Math.floor(currentCycleTime / phaseDuration);
            const nextPhaseIndex = (currentPhaseIndex + 1) % dayCyclePhases.length;
            const alpha = (currentCycleTime % phaseDuration) / phaseDuration;
            const currentParams = dayCycleParameters[dayCyclePhases[currentPhaseIndex]];
            const nextParams = dayCycleParameters[dayCyclePhases[nextPhaseIndex]];
            
            scene.background.lerpColors(currentParams.background, nextParams.background, alpha);
            hemiLight.color.lerpColors(currentParams.hemiSky, nextParams.hemiSky, alpha);
            hemiLight.groundColor.lerpColors(currentParams.hemiGround, nextParams.hemiGround, alpha);
            dirLight.color.lerpColors(currentParams.dirLight, nextParams.dirLight, alpha);
            dirLight.intensity = THREE.MathUtils.lerp(currentParams.dirIntensity, nextParams.dirIntensity, alpha);
            
            let normalizedDayBrightness = (dirLight.intensity - 0.6) / (1.2 - 0.6);
            normalizedDayBrightness = Math.max(0, Math.min(1, normalizedDayBrightness));
            const streetLightGlowFactor = 1.0 - normalizedDayBrightness;
            
            streetLights.forEach(lightGroup => {
                if(lightGroup.userData.isHit) return;
                const isNightTime = dayCyclePhases[currentPhaseIndex] === 'NIGHT' || dayCyclePhases[currentPhaseIndex] === 'EVENING';
                const bulb = lightGroup.children.find(child => child instanceof THREE.PointLight);
                const emissiveBulb = lightGroup.children.find(child => child.material && child.material.emissive);
                if (bulb) bulb.intensity = isNightTime ? streetLightGlowFactor * 1.5 : 0;
                if(emissiveBulb) emissiveBulb.material.emissiveIntensity = isNightTime ? streetLightGlowFactor : 0;
            });

            const isNight = dayCyclePhases[currentPhaseIndex] === 'NIGHT' || dayCyclePhases[currentPhaseIndex] === 'EVENING';

            if (niceCitySign) {
                niceCitySign.material.opacity = Math.max(0, 1.0 - normalizedDayBrightness * 1.5);
            }

            if (player && player.userData.lights) {
                player.userData.lights.headlight1.visible = isNight;
                player.userData.lights.headlight2.visible = isNight;
                player.userData.lights.taillight1.material.emissiveIntensity = isNight ? 1.8 : 0.2;
                player.userData.lights.taillight2.material.emissiveIntensity = isNight ? 1.8 : 0.2;
            }

            if (policeCar && policeCar.userData.lights) {
                policeCar.userData.lights.headlight1.visible = isNight;
                policeCar.userData.lights.headlight2.visible = isNight;
                policeCar.userData.lights.taillight1.material.emissiveIntensity = isNight ? 1.5 : 0.2;
                policeCar.userData.lights.taillight2.material.emissiveIntensity = isNight ? 1.5 : 0.2;
            }
            
            trafficCars.forEach(car => {
                if (car && car.userData && car.userData.lights) {
                    if (car.userData.type === 'ambulance' && car.userData.lights.roofLight1) {
                        const time = clock.getElapsedTime() * 5;
                        car.userData.lights.roofLight1.material.emissiveIntensity = Math.sin(time) > 0 ? 1.0 : 0.0;
                        car.userData.lights.roofLight2.material.emissiveIntensity = Math.sin(time) < 0 ? 1.0 : 0.0;
                    }

                    if (car.userData.lights.headlight1) car.userData.lights.headlight1.visible = isNight;
                    if (car.userData.lights.headlight2) car.userData.lights.headlight2.visible = isNight;
                    if (car.userData.lights.taillight1) car.userData.lights.taillight1.material.emissiveIntensity = isNight ? 1.0 : 0.2;
                    if (car.userData.lights.taillight2) car.userData.lights.taillight2.material.emissiveIntensity = isNight ? 1.0 : 0.2;
                }
            });
        }

        function createRoadAndSidewalks() {
            road = new THREE.Group();
            const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x808080, shininess: 20 });
            for (let i = 0; i < SEGMENT_COUNT; i++) {
                const segment = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH, SEGMENT_LENGTH), roadMaterial);
                segment.rotation.x = -Math.PI / 2; segment.position.z = i * SEGMENT_LENGTH - TOTAL_LENGTH / 2;
                segment.receiveShadow = true; road.add(segment);
            }
            scene.add(road);
        }

        function createCitySkylineTexture() {
            const canvas = document.createElement('canvas');
            const canvasWidth = 1024;
            const canvasHeight = 512;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            ctx.fillStyle = 'rgba(20, 20, 35, 0.6)';
            let xPos = 0;
            while (xPos < canvasWidth) {
                const buildingWidth = Math.random() * 40 + 20;
                const buildingHeight = Math.random() * 200 + 150;
                ctx.fillRect(xPos, canvasHeight - buildingHeight, buildingWidth, buildingHeight);
                xPos += buildingWidth + Math.random() * 5;
            }
            
            xPos = 0;
            while (xPos < canvasWidth) {
                const buildingWidth = Math.random() * 60 + 30;
                const buildingHeight = Math.random() * 250 + 80;
                ctx.fillStyle = new THREE.Color(VICE_CITY_COLORS[Math.floor(Math.random() * VICE_CITY_COLORS.length)]).getStyle();
                ctx.fillRect(xPos, canvasHeight - buildingHeight, buildingWidth, buildingHeight);
                
                ctx.fillStyle = 'rgba(255, 255, 220, 0.9)';
                for (let y = canvasHeight - buildingHeight + 10; y < canvasHeight - 10; y += 12) {
                    for (let x = xPos + 8; x < xPos + buildingWidth - 8; x += 12) {
                        if (Math.random() > 0.3) {
                            ctx.fillRect(x, y, 5, 7);
                        }
                    }
                }
                xPos += buildingWidth + Math.random() * 10;
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createSeaSkylineTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, 1024, 256);

            const gradient = ctx.createLinearGradient(0, 0, 0, 256);
            gradient.addColorStop(0, "rgba(44, 0, 46, 0)");
            gradient.addColorStop(0.7, "rgba(44, 0, 46, 0.5)");
            gradient.addColorStop(1, "rgba(106, 0, 95, 0.7)");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 256);

            ctx.fillStyle = '#181022';
            ctx.beginPath();
            ctx.moveTo(0, 210);
            ctx.quadraticCurveTo(200, 170, 400, 200);
            ctx.quadraticCurveTo(600, 230, 800, 190);
            ctx.quadraticCurveTo(900, 170, 1024, 180);
            ctx.lineTo(1024, 256);
            ctx.lineTo(0, 256);
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }
        
        function createNiceCitySignTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, 1024, 512);

            const hillGradient = ctx.createLinearGradient(0, 250, 0, 512);
            hillGradient.addColorStop(0, "rgba(20, 10, 5, 0)");
            hillGradient.addColorStop(0.5, "#2a221a");
            hillGradient.addColorStop(1, "#1c1511");
            ctx.fillStyle = hillGradient;
            
            ctx.beginPath();
            ctx.moveTo(0, 512);
            ctx.lineTo(0, 400);
            ctx.quadraticCurveTo(256, 300, 512, 350);
            ctx.quadraticCurveTo(768, 400, 1024, 320);
            ctx.lineTo(1024, 512);
            ctx.closePath();
            ctx.fill();

            ctx.font = "bold 120px 'Bebas Neue', sans-serif";
            ctx.textAlign = 'center';
            
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillText("NICE CITY", 512 + 5, 450 + 5);
            
            const textGradient = ctx.createLinearGradient(0, 350, 0, 450);
            textGradient.addColorStop(0, "#ffffff");
            textGradient.addColorStop(0.8, "#dddddd");
            textGradient.addColorStop(1, "#bbbbbb");
            ctx.fillStyle = textGradient;
            ctx.strokeStyle = "#888888";
            ctx.lineWidth = 1;
            
            ctx.fillText("NICE CITY", 512, 450);
            ctx.strokeText("NICE CITY", 512, 450);

            return new THREE.CanvasTexture(canvas);
        }
        
        function createSkylinePlane(texture) {
            const skylineMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });

            const skylineGeometry = new THREE.PlaneGeometry(SEGMENT_LENGTH, 300);
            const skylinePlane = new THREE.Mesh(skylineGeometry, skylineMaterial);
            return skylinePlane;
        }

        function createScenery(){
            sidewalkLeft = new THREE.Group(); sidewalkRight = new THREE.Group(); beach = new THREE.Group();
            ocean = new THREE.Group(); buildingGround = new THREE.Group();
            const sidewalkMaterial = new THREE.MeshPhongMaterial({color:0xd2b48c});
            const beachMaterial = new THREE.MeshPhongMaterial({color:0xf2d16b});
            const oceanMaterial = new THREE.MeshPhongMaterial({color:0x0066cc, transparent:true, opacity:0.8});

            const groundTexture = createGroundTexture();
            groundTexture.wrapS = THREE.RepeatWrapping;
            groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(100, 100);
            const groundMaterial = new THREE.MeshPhongMaterial({ map: groundTexture });

            const cityTexture = createCitySkylineTexture();
            const seaTexture = createSeaSkylineTexture();

            for(let i = 0; i < SEGMENT_COUNT; i++){
                const zPosition = i * SEGMENT_LENGTH - TOTAL_LENGTH / 2;
                const sidewalkL = new THREE.Mesh(new THREE.PlaneGeometry(SIDEWALK_WIDTH, SEGMENT_LENGTH), sidewalkMaterial);
                sidewalkL.rotation.x = -Math.PI / 2; sidewalkL.position.set(-ROAD_WIDTH/2 - SIDEWALK_WIDTH/2, 0.1, zPosition); sidewalkL.receiveShadow = true; sidewalkLeft.add(sidewalkL);
                const sidewalkR = new THREE.Mesh(new THREE.PlaneGeometry(SIDEWALK_WIDTH, SEGMENT_LENGTH), sidewalkMaterial);
                sidewalkR.rotation.x = -Math.PI / 2; sidewalkR.position.set(ROAD_WIDTH/2 + SIDEWALK_WIDTH/2, 0.1, zPosition); sidewalkR.receiveShadow = true; sidewalkRight.add(sidewalkR);
                const groundR = new THREE.Mesh(new THREE.PlaneGeometry(400, SEGMENT_LENGTH), groundMaterial);
                groundR.rotation.x = -Math.PI / 2; groundR.position.set(ROAD_WIDTH/2 + SIDEWALK_WIDTH + 200, 0.05, zPosition); groundR.receiveShadow = true; buildingGround.add(groundR);
                const beachSegment = new THREE.Mesh(new THREE.PlaneGeometry(100, SEGMENT_LENGTH), beachMaterial);
                beachSegment.rotation.x = -Math.PI / 2; beachSegment.position.set(-ROAD_WIDTH/2 - SIDEWALK_WIDTH - 50, 0, zPosition); beach.add(beachSegment);
                const oceanSegment = new THREE.Mesh(new THREE.PlaneGeometry(200, SEGMENT_LENGTH), oceanMaterial);
                oceanSegment.rotation.x = -Math.PI / 2; oceanSegment.position.set(-ROAD_WIDTH/2 - SIDEWALK_WIDTH - 150, -0.1, zPosition); ocean.add(oceanSegment);

                const cityPlane = createSkylinePlane(cityTexture);
                cityPlane.position.set(ROAD_WIDTH / 2 + SIDEWALK_WIDTH + 350, 150, zPosition);
                cityPlane.rotation.y = -Math.PI / 2;
                citySkyline.push(cityPlane);
                scene.add(cityPlane);
                
                const seaPlane = createSkylinePlane(seaTexture);
                seaPlane.position.set(-ROAD_WIDTH / 2 - SIDEWALK_WIDTH - 250, 130, zPosition);
                seaPlane.rotation.y = Math.PI / 2;
                seaSkyline.push(seaPlane);
                scene.add(seaPlane);
            }
            scene.add(sidewalkLeft, sidewalkRight, beach, ocean, buildingGround);

            let lastZ = -TOTAL_LENGTH / 2;
            let lastWallZ = -TOTAL_LENGTH / 2;
            const totalObjects = 150;
            for (let i = 0; i < totalObjects; i++) {
                const zPos = lastZ + 15 + Math.random() * 25;
                lastZ = zPos;
                if (zPos > TOTAL_LENGTH / 2) break;

                const xBase = ROAD_WIDTH / 2 + SIDEWALK_WIDTH;
                createBuilding(xBase + 10 + Math.random() * 80, zPos);
            }
            
            for (let i = 0; i < 40; i++) {
                const zPos = lastWallZ + 30;
                lastWallZ = zPos;
                if (zPos > TOTAL_LENGTH / 2) break;
                const xPos = ROAD_WIDTH / 2 + SIDEWALK_WIDTH + 110;
                createBuilding(xPos, zPos, true);
            }

            for(let i = 0; i < 100; i++) createPalmTree(-ROAD_WIDTH / 2 - SIDEWALK_WIDTH - Math.random() * 95, Math.random() * TOTAL_LENGTH - TOTAL_LENGTH / 2);

            for (let i = 0; i < 80; i++) {
                const pedestrian = createPedestrian();
                const zPos = Math.random() * TOTAL_LENGTH - TOTAL_LENGTH / 2;
                if (Math.random() < 0.5) {
                    const xPos = ROAD_WIDTH / 2 + SIDEWALK_WIDTH + 2 + Math.random() * 50;
                    pedestrian.position.set(xPos, 1.2, zPos);
                } else {
                    const xPos = -ROAD_WIDTH / 2 - SIDEWALK_WIDTH - Math.random() * 95;
                    pedestrian.position.set(xPos, 1.2, zPos);
                }
                pedestrians.push(pedestrian);
                scene.add(pedestrian);
            }

            for (let i = 0; i < 30; i++) {
                const debris = createFlyingDebris();
                const xPos = Math.random() * (ROAD_WIDTH + SIDEWALK_WIDTH * 2) - (ROAD_WIDTH / 2 + SIDEWALK_WIDTH);
                const zPos = Math.random() * TOTAL_LENGTH - TOTAL_LENGTH / 2;
                debris.position.set(xPos, Math.random() * 5, zPos);
                flyingDebris.push(debris);
                scene.add(debris);
            }

            for (let i = 0; i < 15; i++) {
                const carTexture = createParkedCarTexture();
                const carMat = new THREE.MeshBasicMaterial({ map: carTexture, transparent: true });
                const carGeo = new THREE.PlaneGeometry(5, 2.5);
                const parkedCar = new THREE.Mesh(carGeo, carMat);

                const xPos = ROAD_WIDTH / 2 + SIDEWALK_WIDTH * 0.7;
                const zPos = Math.random() * TOTAL_LENGTH - TOTAL_LENGTH / 2;
                parkedCar.position.set(xPos, 1.2, zPos);
                parkedCar.rotation.y = -Math.PI / 2;
                parkedCars.push(parkedCar);
                scene.add(parkedCar);
            }

            for (let i = 0; i < 40; i++) {
                const towel = createBeachDetail('towel');
                const xPos = -ROAD_WIDTH / 2 - SIDEWALK_WIDTH - Math.random() * 90;
                const zPos = Math.random() * TOTAL_LENGTH - TOTAL_LENGTH / 2;
                towel.position.set(xPos, 0.1, zPos);
                beachDetails.push(towel);
                scene.add(towel);
            }
        }

        function createPalmTree(x, z) {
            const palm = new THREE.Group();
            const trunkHeight = 12 + Math.random() * 4;
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, trunkHeight, 8), new THREE.MeshPhongMaterial({ color: 0x4a3728, flatShading: true }));
            trunk.position.y = trunkHeight / 2; trunk.castShadow = true; palm.add(trunk);
            const leafMaterial = new THREE.MeshPhongMaterial({ color: 0x0f8a5f, flatShading: true, side: THREE.DoubleSide });
            for (let i = 0; i < 10; i++) {
                const leaf = new THREE.Mesh(new THREE.PlaneGeometry(6, 1.5, 1, 1), leafMaterial);
                leaf.castShadow = true; leaf.position.y = trunkHeight;
                leaf.rotation.y = (i / 10) * Math.PI * 2 + Math.random() * 0.5;
                leaf.rotation.x = Math.PI / 4 + Math.random() * 0.2;
                palm.add(leaf);
            }
            palm.position.set(x, 0, z); palmTrees.push(palm); scene.add(palm);
        }

        function createStreetLights() {
            const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const bulbMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 1.0 });
            const spacing = 220;
            for (let i = 0; i < TOTAL_LENGTH / spacing; i++) {
                const zPos = i * spacing - TOTAL_LENGTH / 2;
                [-1, 1].forEach(side => {
                    const lightGroup = new THREE.Group();
                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 8, 8), poleMaterial);
                    pole.position.y = 4;
                    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.4), bulbMaterial.clone());
                    const light = new THREE.PointLight(0xffd700, 1, 30, 2);
                    bulb.position.y = 8.2;
                    light.position.y = 8;
                    lightGroup.add(pole, bulb, light);
                    lightGroup.position.set((ROAD_WIDTH / 2 + 2) * side, 0, zPos);
                    lightGroup.castShadow = true;
                    lightGroup.userData = { isStreetlight: true, isHit: false, isFalling: false };
                    streetLights.push(lightGroup); scene.add(lightGroup);
                });
            }
        }

        function createRain() {
            const vertices = [];
            for (let i = 0; i < 15000; i++) vertices.push(THREE.MathUtils.randFloatSpread(50), THREE.MathUtils.randFloat(0, 50), THREE.MathUtils.randFloatSpread(50));
            const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            rain = new THREE.Points(geometry, new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.1, transparent: true }));
            rain.visible = false; scene.add(rain);
        }

        function toggleRain(state) {
            isRaining = state; rain.visible = state;
            const wetRoadColor = new THREE.Color(0x222222); const dryRoadColor = new THREE.Color(0x808080);
            road.children.forEach(segment => {
                segment.material.color = state ? wetRoadColor : dryRoadColor;
                segment.material.shininess = state ? 80 : 10;
                segment.material.needsUpdate = true;
            });
        }

        function updateRain(deltaTime) {
            if (!rain) return; const positions = rain.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] -= 20 * deltaTime;
                if (positions[i] < -5) positions[i] = 50;
            }
            rain.geometry.attributes.position.needsUpdate = true;
            if (player) { rain.position.x = player.position.x; rain.position.z = player.position.z; }
        }

        function updatePedestrians() {
            [...pedestrians, ...cityDecorations].forEach(p => {
                p.rotation.y = Math.atan2( ( camera.position.x - p.position.x ), ( camera.position.z - p.position.z ) );
            });
             parkedCars.forEach(p => {
                p.rotation.y = -Math.PI/2 + Math.atan2( ( camera.position.x - p.position.x ), ( camera.position.z - p.position.z ) );
            });
        }

        function updateFlyingDebris(deltaTime) {
            flyingDebris.forEach(debris => {
                debris.position.add(debris.userData.velocity);
                debris.rotation.x += debris.userData.rotationSpeed.x;
                debris.rotation.y += debris.userData.rotationSpeed.y;
                debris.rotation.z += debris.userData.rotationSpeed.z;

                if (debris.position.y > 10) {
                    debris.userData.velocity.y = -0.02;
                }
                if (debris.position.y < 0.2) {
                    debris.userData.velocity.y = Math.random() * 0.05 + 0.02;
                }
            });
        }

        function initializeGame() {
            try {
                clock = new THREE.Clock(); scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000);
                scene.add(camera);

                const niceCityTexture = createNiceCitySignTexture();
                const signMaterial = new THREE.MeshBasicMaterial({ map: niceCityTexture, transparent: true, depthWrite: false });
                const signGeometry = new THREE.PlaneGeometry(1200, 600);
                niceCitySign = new THREE.Mesh(signGeometry, signMaterial);
                niceCitySign.position.set(0, 120, -1300);
                scene.add(niceCitySign);


                isIntroPlaying = true;
                cinematicCameraTarget = new THREE.Vector3();

                renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game'), antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true;
                scene.background = dayCycleParameters.NIGHT.background.clone();
                
                hemiLight = new THREE.HemisphereLight(dayCycleParameters.NIGHT.hemiSky, dayCycleParameters.NIGHT.hemiGround, dayCycleParameters.NIGHT.dirIntensity);
                scene.add(hemiLight);
                dirLight = new THREE.DirectionalLight(dayCycleParameters.NIGHT.dirLight, dayCycleParameters.NIGHT.dirIntensity);
                dirLight.position.set(-50, 40, 20); dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.near = 0.5; dirLight.shadow.camera.far = 500;
                dirLight.shadow.camera.left = -100; dirLight.shadow.camera.right = 100;
                dirLight.shadow.camera.top = 100; dirLight.shadow.camera.bottom = -100;
                scene.add(dirLight);

                createWorld();
                updateHealth();
                updatePlayerHUD();

                camera.position.set(player.position.x + 10, player.position.y + 4, player.position.z + 10);
                camera.lookAt(player.position);

                setupControls();
                areHazardLightsOn = true;

                animate();

                window.addEventListener('resize', onWindowResize, false);
                document.getElementById('game').classList.add('visible');

                setTimeout(() => {
                    showSpeechBubble('player', 'Hmm, güzel araba... Artık benim.');
                }, 1500);

                document.getElementById('mission-container').style.display = 'none';

                if (sounds?.engine) sounds.engine.play();
            } catch(e) {
                displayError(e);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isGameOver) return;
            const deltaTime = clock.getDelta();

            let effectiveDeltaTime = deltaTime;
            let currentSpeed = speed;

            if (!julieMissionTriggered && score >= 20000) {
                julieMissionTriggered = true;
                const missionContainer = document.getElementById('mission-container');
                const missionText = document.getElementById('mission-text');
                const missionBtn = document.getElementById('generate-mission-btn');
                missionText.innerText = "Julie'yi etkiledin! Şimdi onu malikanesine bırak.";
                missionBtn.style.display = 'none';
                if (missionHideTimeout) clearTimeout(missionHideTimeout);
                if (!missionContainer.classList.contains('visible')) {
                    missionContainer.style.display = 'flex';
                    setTimeout(() => missionContainer.classList.add('visible'), 10);
                }
            }

            if (isIntroPlaying) {
                cinematicCameraTarget.set(
                    player.position.x * 0.6,
                    player.position.y + 12 - (speed / 5.5 * 2),
                    player.position.z + 25 - (speed / 5.5 * 5)
                );
                camera.position.lerp(cinematicCameraTarget, deltaTime * 0.6);
                const lookAtTarget = new THREE.Vector3(player.position.x, player.position.y + 2.0, player.position.z);
                camera.lookAt(lookAtTarget);
                if (camera.position.distanceTo(cinematicCameraTarget) < 1.0) {
                    isIntroPlaying = false;
                    document.getElementById('ui-container').classList.add('visible');
                    if (window.innerWidth <= 768) {
                        document.getElementById('mobile-controls').classList.add('visible');
                    }
                }
                renderer.render(scene, camera);
                return;
            }

            if (isRampJumpingCinematic) {
                effectiveDeltaTime *= 0.3;
                currentSpeed *= 0.3;

                rampJumpCinematicTimer -= deltaTime;
                if (rampJumpCinematicTimer <= 0) {
                    isRampJumpingCinematic = false;
                    shakeCamera(0.4);
                }
            } else {
                updatePlayerMovement();
                updatePoliceAI(deltaTime);
                checkPoliceCollisions();
                checkDestructibleCollisions();
                checkCollisions();
            }

            checkRampJumps();

            if (player.userData.isJumping) {
                player.position.y += player.userData.verticalVelocity * effectiveDeltaTime;
                player.userData.verticalVelocity -= 25 * effectiveDeltaTime;
                if (player.position.y <= 0) {
                    player.position.y = 0;
                    player.userData.isJumping = false;
                    player.userData.verticalVelocity = 0;
                    if(!isRampJumpingCinematic) shakeCamera(0.2);
                }
            }

            const topSpeed = 5.5;
            if (isRadioPlaying && sounds.radio && sounds.engine) {
                const normalizedSpeed = Math.min(speed / topSpeed, 1.0);
                const targetRadioVol = RADIO_VOL_MAX - (normalizedSpeed * (RADIO_VOL_MAX - RADIO_VOL_MIN));
                const targetEngineVol = ENGINE_VOL_MIN + (normalizedSpeed * (ENGINE_VOL_MAX - ENGINE_VOL_MIN));
                sounds.radio.volume(THREE.MathUtils.lerp(sounds.radio.volume(), targetRadioVol, 0.05));
                sounds.engine.volume(THREE.MathUtils.lerp(sounds.engine.volume(), targetEngineVol, 0.05));
            }
            if (policeDisableTimer > 0) policeDisableTimer -= deltaTime;
            if(hasPlayerMoved) gameTime += deltaTime;
            if (areHazardLightsOn) { if(player && player.userData.lights) Object.values(player.userData.lights).forEach(light => {
                if (light && light.isMesh) {
                    light.visible = Math.sin(clock.getElapsedTime() * 8) > 0;
                }
            }); }
            if (policeSpawnTimer > 0) { policeSpawnTimer -= deltaTime; if (policeSpawnTimer <= 0) { spawnPoliceCar(); startGame(); } }
            if (hasPlayerMoved && !isBoosting && nitroCharges === 0) { if (cleanDrivingTime < BOOST_CHARGE_TIME) cleanDrivingTime += deltaTime; else if (!isBoostAvailable) { isBoostAvailable = true; updateBoostUI(); } }
            if (isBoosting) { boostTimeRemaining -= deltaTime; if (boostTimeRemaining <= 0) isBoosting = false; }
            if (hasPlayerMoved && wantedLevel > 0 && gameTime > nextChatterTime) { generateRadioChatter(); nextChatterTime = gameTime + CHATTER_INTERVAL + Math.random() * 10; }
            if (hasPlayerMoved && gameTime > nextMissionPromptTime) {
                const missionContainer = document.getElementById('mission-container');
                if (missionContainer && !missionContainer.classList.contains('visible') && !julieMissionTriggered) {
                    if (missionHideTimeout) clearTimeout(missionHideTimeout);
                    document.getElementById('mission-text').innerText = "Yeni bir görev almak için düğmeye bas!";
                    document.getElementById('generate-mission-btn').disabled = false;
                    document.getElementById('generate-mission-btn').innerHTML = '✨ Yeni Görev Al';
                    document.getElementById('generate-mission-btn').style.display = 'block';
                    missionContainer.style.display = 'flex';
                    setTimeout(() => missionContainer.classList.add('visible'), 10);
                    missionHideTimeout = setTimeout(() => {
                        missionContainer.classList.remove('visible');
                        missionContainer.addEventListener('transitionend', () => {
                            if (!missionContainer.classList.contains('visible')) { missionContainer.style.display = 'none'; }
                        }, { once: true });
                    }, 3000);
                }
                nextMissionPromptTime = gameTime + MISSION_PROMPT_INTERVAL + Math.random() * 15;
            }

            trafficCars.forEach(car => {
                if (car.userData.type === 'ambulance' && !car.userData.healedPlayer) {
                    const distance = player.position.distanceTo(car.position);
                    const proximityThreshold = 15;
                    if (distance < proximityThreshold) {
                        playerHealth = Math.min(100, playerHealth + 10);
                        car.userData.healedPlayer = true;
                        updateHealth();
                        showSpeechBubble('player', '+10 Can!');
                        if (sounds.heal_sound) sounds.heal_sound.play();
                    }
                }
            });

            waterMaterials.forEach(mat => {
                mat.normalMap.offset.x += 0.0005;
                mat.normalMap.offset.y += 0.0002;
            });

            updateDayCycle(deltaTime);
            updateNitroFlames();
            if (canBeCaught && !isGameOver && clock.getElapsedTime() > nextSpeechBubbleTime) {
                if (Math.random() < 0.5) { showSpeechBubble('police'); } else { showSpeechBubble('player'); }
                nextSpeechBubbleTime = clock.getElapsedTime() + SPEECH_BUBBLE_INTERVAL + (Math.random() * 4 - 2);
            }
            if (wantedLevel > 0 && wantedLevelCooldown > 0) { wantedLevelCooldown -= deltaTime; if (wantedLevelCooldown <= 0) { wantedLevel--; updateStarsUI(); if (wantedLevel > 0) wantedLevelCooldown = 5; } }

            score += speed;
            if (Math.floor(score) % 100 === 0) updatePlayerHUD();

            updateTraffic(effectiveDeltaTime);
            updatePoliceShooting(effectiveDeltaTime);
            updateDebris(effectiveDeltaTime);
            updateBulletSparks(effectiveDeltaTime);
            if (isRaining) updateRain(effectiveDeltaTime);
            updateFallingObjects(effectiveDeltaTime);
            updateCamera();
            moveWorld(currentSpeed);
            updatePedestrians();
            updateFlyingDebris(effectiveDeltaTime);

            const time = clock.getElapsedTime() * 5;
            if (policeCar && sirenLightRed && sirenLightBlue) {
                 sirenLightRed.material.emissiveIntensity = Math.sin(time) > 0 ? 2.0 : 0.0;
                 sirenLightBlue.material.emissiveIntensity = Math.sin(time) < 0 ? 2.0 : 0.0;
            }

            if (!policeCar && wantedLevel > 0 && hasPlayerMoved && !isGameOver) { spawnPoliceCar(); }
            renderer.render(scene, camera);
        }

        window.addEventListener('DOMContentLoaded', () => {
            loadSounds();
            loadAssets();
            setupGameStart();
        });

    </script>
</body>
</html>